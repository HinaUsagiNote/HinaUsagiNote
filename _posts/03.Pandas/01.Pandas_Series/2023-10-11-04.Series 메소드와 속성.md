---
layout: single
title: 'Series 메소드와 속성'
typora-root-url: ../
---

<b style='font-size:2em'>판다스 (Pandas)</b>

# Pandas 개요
- 데이터 분석과 관련된 다양한 기능을 제공하는 파이썬 패키지
    - 데이터 셋을 이용한 다양한 통계 처리 기능을 제공한다.
    - 표 형태의 데이터를 다루는데 특화된 파이썬 모듈.
        - 엑셀의 기능을 제공하는 파이썬 모듈이라고 생각하면 이해가 쉽다.
    - 표 형태의 데이터를 다루기 위한 **시리즈(Series)** 와 **데이터프레임(DataFrame)** 클래스 제공
        - Series : 1차원 자료구조를 표현
        - DataFrame : 2차원 행렬구조의 표(table)를 표현

- **설치**
    - `pip install pandas`
    - `conda instll pandas`
- **공식 홈페이지**
    - https://pandas.pydata.org/
    - https://pandas.pydata.org/docs/


# Series

## Series 개요
- **1차원** 자료구조
- DataFrame(표)의 **한 행(row)** 이나 **한 열(column)** 을 표현한다.
- 각 원소는 **index**와 i**ndex 이름**을 가지며 그것들을 이용해 사용할 수 있다.
- 벡터화 연산(element-wise 연산)을 지원
    - Series 객체에 연산을 하면 각각의 Series 원소들에 연산이 된다.
- Series를 구성하는 원소들을 다루는 다양한 메소드 제공    


```python
# 백터화
[1,2,3] + [10,20,30]
# series => Class
```




    [1, 2, 3, 10, 20, 30]



## Series생성
- 구문
    - `Series(1차원 배열형태 자료구조)`
> #### 배열형태(array-like) 자료구조    
> - 리스트
> - 튜플
> - 넘파이 배열(ndarray)


```python
# padnas 모듈을 import -> 관례적으로 alias(별청)을 pd
```


```python
import pandas as pd
```


```python
# Series 생성
## 작은 타입을 큰타입을 변경
### bool < int < float < str
```


```python
s1 = pd.Series([1,2,3,4,5,], dtype='int8') # dtype : int64 -> int8 dtype 변경
```


```python
print(type(s1))
```

    <class 'pandas.core.series.Series'>



```python
print(s1)
```

    0    1
    1    2
    2    3
    3    4
    4    5
    dtype: int8


```
index이름      값 
   0           1
   1           2
   2           3
   3           4
   4           5
dtype: int64 = 값들의 datatype
```

- dtypy : int64 (int : 정수, 64 : bit수)
    - 정수 : int8, int16, int32, int 64
    - 부호없는정수: unit8, unit16, unit32, unit64 
    - 실수 : float16, float32, float64
- index이름
    - 각 원소(값)의 식별자
    - Series를 생설할때 명시하지 않으면 순번(index)가 index이름이 된다.
    - index와 index이름 은 서로 같지 않다.


```python
# Series의 속성들을 조회
print('데이터타입:', s1.dtype)
```

    데이터타입: int8



```python
print('원소의 개수:', s1.size)
```

    원소의 개수: 5



```python
print('Series의 형태:', s1.shape) # Tuple, 차원별 데이터개수
```

    Series의 형태: (5,)


## Series안의 원소(element) 접근 - Indexing과 Slicing

- Index는 Series에 저장된 각 원소를 구분하는 식별자로 각 원소를 사용할때 사용한다. Series의 원소들은 두 종류의 index를 가진다.
    1. **index(순번)**
    2.  - <del>`series[순번]`</del> : deprecated
        - 자동으로 배정되는 순번. 
        - **리스트나 튜플의 index**와 동일하다.
        - 0 부터 1씩 증가하는 양수 index와 -1 부터 1씩 감소하는 음수 index 두가지가 붙는다. 양수 index는 앞에서 부터, 음수 index는 뒤에서 부터 붙는다.
    3. **index name(index이름)**
        - 명시적으로 각 index에 지정하는 이름
        - **딕셔너리의 key**의 역할을 한다.
            - Series의 index name은 중복될 수 있다. 
        - 생략하면 양수 index가 index name이 된다.
    - Index와 index name 두가지의 식별자가 붙는 것은 Series, DataFrame 동일하다.
    - Series나 DataFrame을 출력하면 나오는 index는 index name이다. 자동으로 붙는 index는 판다스 내부에서 관리된다.    


```python
# index(순번) 양수index, 음수index 두가지 index
a = [1,2,3]
a[0],a[-3]
```




    (1, 1)




```python
s2 = pd.Series([10,20,30,40], index=['A','가','A','나'])
s2
```




    A    10
    가    20
    A    30
    나    40
    dtype: int64




```python
# index name 조회
print(s1.index)
```

    RangeIndex(start=0, stop=5, step=1)



```python
print(s2.index)
```

    Index(['A', '가', 'A', '나'], dtype='object')


### Indexing
- 한개의 원소를 식별할 때 사용한다.
- **index 순번으로 조회**
    - `Series[순번]`
    - `Series.iloc[순번]`
- **index 이름으로 조회**
    - `Series[index 이름]`
    - `Series.loc[index 이름]`
    - index 이름이 문자열이면 문자열(" ") 로, 정수이면 정수로 호출
        - `s['name'], s[2], s.loc['name'], s.loc[2]`
    - Series.index 이름
        - index의 이름이 **파이썬 식별자 규칙에 맞을** 경우 `. 표기법` 사용 할 수 있다.. 
    
- **Series[index]는 기본적으로 Index명으로 조회한다.**
    - index 이름과 index의 타입이 다르면 알아서 처리해준다. 
    - index 이름의 type이 int일 때 index(순번)으로 조회하고 싶은 경우 (index이름과 index 의 타입이 int로 같은 경우를 말한다.)
        - iloc indexer를 사용  
        - `Series객체.iloc[순번]`
- **팬시(fancy) 인덱싱**
    -`Series[index리스트]`
    - 한번에 여러개의 원소를 조회할 때 그 index들을 list로 묶어서 전달한다.
        - `series[[1,2,3]]`
    


```python
s1= pd.Series([10,20,30,40,50,60])
```


```python
# indexer
s1
```




    0    10
    1    20
    2    30
    3    40
    4    50
    5    60
    dtype: int64




```python
s1[0] # index 이름
```




    10




```python
# 음수 index 조회 
# s1[-1] # error index name: int , index : int => 둘의 타입이 동일 ==> 구분안됨. => s1[-1] => index name에서 찾는다.
s1.iloc[-1]
```




    60




```python
s2 = pd.Series([50,70,80,60,100], index=['국어','영어','수학','과학','미술 점수'])
s2
```




    국어        50
    영어        70
    수학        80
    과학        60
    미술 점수    100
    dtype: int64




```python
# index로 조회 -> iloc indexer
s2.iloc[0], s2.iloc[-2]
```




    (50, 80)




```python
# index 이름 - loc indexer
s2.loc['국어'], s2.loc['수학']
```




    (50, 80)




```python
# index 이름 : str, index: int -> 둘이 다른타입 -> 타입으로 구분
s2[0], s2[-1], s2['과학']
# 지금은 되는데 나중에는 안될수 있다는 경고, 앞으로는 조회할때는 iloc로 사용
```

    C:\Users\world\AppData\Local\Temp\ipykernel_7692\2049093597.py:2: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
      s2[0], s2[-1], s2['과학']





    (50, 60, 60)




```python
s2['수학'], s2.loc['수학']
```




    (80, 80)




```python
s2['미술 점수']
# s2.'미술 점수' Error : invalid syntax => .표기법 식별자 규칙 어긋남
```




    100




```python
# 여러개 원소를 조회
## 조회하려는 index(index name)을 리스토로 묶어서 index에 전달 -> fancy indexing
s1[[1, 4, 5]]
```




    1    20
    4    50
    5    60
    dtype: int64




```python
s2.iloc[[0, 1, 2]]
```




    국어    50
    영어    70
    수학    80
    dtype: int64




```python
s2.loc[['수학','국어','영어','수학']] # 반드시 List로 두번 묶어야된다. 
```




    수학    80
    국어    50
    영어    70
    수학    80
    dtype: int64




```python
l = [1,2,3,4]
l[2],l[1] 
# List 에서는 한번에 조회 못함
```




    (3, 2)



### Slicing
- 범위로 원소들을 조회할 때 사용한다.
- **Series[start index :  stop index : step]**
    - start index 생략 : 0번 부터
    - stop index
        - **index 순번일 경우는 포함 하지는다.**
        - **index 명의 경우는 포함한다.**
    - stop index 생략 : 마지막 index까지
    - step 생략 : 1씩 증가
- **Slicing의 결과는 원본의 참조(View)를 반환**
    - Slicing은 shallow copy를 한다. 그래서 slicing한 결과를 원소를 변경하면 slicing 했던 원본도 같이 바뀐다.
    - 원본은 변경되지 않게 하려면 `slicing결과.copy()` 를 이용해 deep copy를 해야 한다.

> - <b style='font-size:1.3em'>shallow copy와 deep copy</b>
>    - **deep copy(깊은 복사)**
>        - 원본과 동일한 값을 가진 새로운 객체를 만들어 반환한다. 그래서 복사본의 값을 변경해도 원본이 변경되지 않는다.
>        - 파이썬 리스트는 slicing시 deep copy를 한다.
>    - **shallow copy(얕은 복사)**
>        - 원본을 반환하여 값 변경시 원본에 영향을 준다.
>        - Series, DataFrame, 넘파이 배열(ndarray)은 slicing 조회 시 shallow copy한다.
>    - **copy() 메소드**
>        - Series, DataFrame, ndarray를 deep copy 한다.


```python
s3 = pd.Series(range(100)) # 0 ~ 99, 100 개
print(s3.size)
s3
```

    100





    0      0
    1      1
    2      2
    3      3
    4      4
          ..
    95    95
    96    96
    97    97
    98    98
    99    99
    Length: 100, dtype: int64




```python
s3[10:30:5] # index조회: 10 ~ 30-1, step : 5
```




    10    10
    15    15
    20    20
    25    25
    dtype: int64




```python
s3.loc[10:30:5] # index이름 조회: 10 ~ 30(포함), step : 5
```




    10    10
    15    15
    20    20
    25    25
    30    30
    dtype: int64




```python
s3[10:15] # step 생략: 1
```




    10    10
    11    11
    12    12
    13    13
    14    14
    dtype: int64




```python
s3[:5] # start 생략: 0 , step 생략: 1
```




    0    0
    1    1
    2    2
    3    3
    4    4
    dtype: int64




```python
s3[90:] # stop: 끝까지
```




    90    90
    91    91
    92    92
    93    93
    94    94
    95    95
    96    96
    97    97
    98    98
    99    99
    dtype: int64




```python
s3[70::5] # start: 70, stop: 생략-끝까지, step: 5
```




    70    70
    75    75
    80    80
    85    85
    90    90
    95    95
    dtype: int64




```python
s3[90:-2] # start: 90, stop: -2(뒤에서 두번째 index)
```




    90    90
    91    91
    92    92
    93    93
    94    94
    95    95
    96    96
    97    97
    dtype: int64




```python
s3[50:30:-3] # start > stop, step : 음수 => reverse(역순 조회)
```




    50    50
    47    47
    44    44
    41    41
    38    38
    35    35
    32    32
    dtype: int64




```python
r = s3[:10] # 0 ~ 9 index
r
```




    0    0
    1    1
    2    2
    3    3
    4    4
    5    5
    6    6
    7    7
    8    8
    9    9
    dtype: int64




```python
# index 0의 값을 100으로 변경
r[0] = 100
r[0]
```




    100




```python
r[7] = 700
r[7]
```




    700




```python
s3[:10]
```




    0    100
    1      1
    2      2
    3      3
    4      4
    5      5
    6      6
    7    700
    8      8
    9      9
    dtype: int64




```python
# deep copy (List) : 원본 값 => R에 원본 값을 복사해서 새로운 List를 만든다. -> R 값 변경시 원본에 영향이 없다
```


```python
# slicing 한 결과를 변경할 때 원본은 변경이 안되도록 할경우 copy()를 사용
r2 = s3[:5].copy() # Series.copy() : 복사한 Series를 생성 (deep copy)
```


```python
r2[0] = 5000
r2[1] = 6000
r2
```




    0    5000
    1    6000
    2    1000
    3       3
    4       4
    dtype: int64




```python
s3[:5]
```




    0     100
    1       1
    2    1000
    3       3
    4       4
    dtype: int64




```python
# shallow copy(Pandas) : 원본 값 => R 에 참조해서 값 변경시 -> 원본도 영향이 있다.
```


```python
s3[2] = 1000
```


```python
r
```




    0     100
    1       1
    2    1000
    3       3
    4       4
    5       5
    6       6
    7     700
    8       8
    9       9
    dtype: int64



## 벡터화 (연산)
- Pandas의 Series나 DataFrame은 연산을 하면  원소 단위로 연산을 한다.
    - **element-wise 연산** 이라고도 한다.
- Series/DataFrame과 값(scalar값)을 연산하면 각 원소들과 값을 연산한다.
- Series끼리 또는 DataFrame끼리 연산을 하면 같은 위치의 원소끼리 연산을 한다.
    - **Index 이름**이 (index가 아닌) 같은 원소끼리 연산한다. 


```python
s1 = pd.Series([10,100,50,30])
```


```python
s2 = pd.Series([100,5,10,300])
```


```python
# Series + 상수 (Scalar)
s1 + 20
```




    0     30
    1    120
    2     70
    3     50
    dtype: int64




```python
s1 - 100
```




    0   -90
    1     0
    2   -50
    3   -70
    dtype: int64




```python
s1 > 50
```




    0    False
    1    False
    2    False
    3    False
    dtype: bool




```python
# Series끼리 연산 : 같은 index name의 원소끼리 연산
s1 + s2
```




    0    110
    1    105
    2     60
    3    330
    dtype: int64




```python
s1 > s2
```




    0    False
    1     True
    2     True
    3    False
    dtype: bool




```python
s1 - s2
```




    0    -90
    1     95
    2     40
    3   -270
    dtype: int64




```python
s3 = pd.Series([1,2,3,4,5,6])
```


```python
# Size가 다른 Series 끼리 연산, 일치하지 않는 index끼리 계산결과 : NaN
s1 + s3
```




    0     11.0
    1    102.0
    2     53.0
    3     34.0
    4      NaN
    5      NaN
    dtype: float64




```python
s4 = pd.Series([10,20,30,40], index=['A','B','C','D'])
```


```python
# s4 > s1 : Error index name이 다르면 계산이 안된다.
```

## Boolean 인덱싱
- Series의 indexing 연산자에 boolean 리스트를 넣으면 True인 index의 값들만 조회한다. 
    - **원하는 조건의 값들을 조회**할 때 사용한다.
    
    
|논리연산자|설명|
|:-:|-|
|&|and연산|
|\||or연산|
|~|not 연산|

    - 논리연산자의 피연산자들은 반드시 ( )로 묶어준다.
    - 파이썬과는 다르게 `and`, `or`, `not`은 예약어는 사용할 수 없다.


```python
s1 =pd.Series([1,2,3,4])
```


```python
# 1, 3 index 조회
## 조회할 Series와 같은 크기(Shape)의 리스트
### 조회할 index-True, 나머지 False
s1[[False, True, False, True]]
```




    1    2
    3    4
    dtype: int64




```python
s1[pd.Series([True,False,True,False])]
```




    0    1
    2    3
    dtype: int64




```python
import numpy as np
s2 = pd.Series(np.random.randint(100, size=100)) # 0 ~  99 사이의 랜덤정수 100개로 구성된 배열(List)을 생성
```


```python
# s2 에서 50보다 큰 값들만 조회.
s2[s2 > 50] # Boolean indexing - 원하는 조건의 값들만 조회.
```




    16    92
    18    82
    2     71
    0     28
    0     28
          ..
    0     28
    50    96
    0     28
    32    94
    34    37
    Length: 100, dtype: int32




```python
# 30 < s2 < 50 : 파이썬가능, 판다스 지원안함
# Pandas => and, or 지원안함.
```


```python
# 30 < s2 < 50 값들을 조회
# and -> &, or -> |, ~ ->  피연사자는 ()로 묶어준다.
s2[(s2 > 30) & (s2 < 50)]
```




    1     31
    7     45
    17    34
    19    37
    20    45
    30    47
    34    37
    38    41
    41    37
    42    42
    46    33
    59    36
    60    38
    64    47
    69    35
    79    41
    83    41
    98    36
    99    38
    dtype: int32




```python
np.where((s2 > 30) & (s2 < 50)) # 조건이 True인 값의 위치(index)를 조회
```




    (array([ 1,  7, 17, 19, 20, 30, 34, 38, 41, 42, 46, 59, 60, 64, 69, 79, 83,
            98, 99], dtype=int64),)




```python
np.where((s2 > 30) & (s2 < 50), 'A','B') # 조건 True = 'A', False = 'B'
```




    array(['B', 'A', 'B', 'B', 'B', 'B', 'B', 'A', 'B', 'B', 'B', 'B', 'B',
           'B', 'B', 'B', 'B', 'A', 'B', 'A', 'A', 'B', 'B', 'B', 'B', 'B',
           'B', 'B', 'B', 'B', 'A', 'B', 'B', 'B', 'A', 'B', 'B', 'B', 'A',
           'B', 'B', 'A', 'A', 'B', 'B', 'B', 'A', 'B', 'B', 'B', 'B', 'B',
           'B', 'B', 'B', 'B', 'B', 'B', 'B', 'A', 'A', 'B', 'B', 'B', 'A',
           'B', 'B', 'B', 'B', 'A', 'B', 'B', 'B', 'B', 'B', 'B', 'B', 'B',
           'B', 'A', 'B', 'B', 'B', 'A', 'B', 'B', 'B', 'B', 'B', 'B', 'B',
           'B', 'B', 'B', 'B', 'B', 'B', 'B', 'A', 'A'], dtype='<U1')




```python
# 30에서 70 사이의 값이 아닌 값들
s2[(s2 < 30) | (s2 > 70)]
```




    0     28
    2     71
    5     16
    6     20
    8     29
    9     17
    10    11
    11    12
    16    92
    18    82
    21     9
    22    95
    24    74
    25    99
    27    10
    28    22
    31    93
    32    94
    33    89
    35    25
    36    26
    37     8
    40    21
    43    26
    45    71
    47     9
    49    96
    50    96
    52    10
    53    99
    54    26
    55     5
    56    14
    57    99
    61    74
    62    77
    63    12
    65     7
    66     7
    70    86
    71    14
    73    13
    74    27
    76    83
    77    82
    78    78
    80    15
    81    73
    85    80
    86    82
    88    94
    89    18
    91    94
    93    23
    94    16
    95     9
    dtype: int32




```python
s2[~(s2 > 30) & (s2 < 700)]
```




    0     28
    5     16
    6     20
    8     29
    9     17
    10    11
    11    12
    21     9
    27    10
    28    22
    35    25
    36    26
    37     8
    40    21
    43    26
    47     9
    52    10
    54    26
    55     5
    56    14
    63    12
    65     7
    66     7
    71    14
    73    13
    74    27
    80    15
    89    18
    93    23
    94    16
    95     9
    dtype: int32




```python
# Series.between(a, b) : a ~ b 사이의 값인지 여부를 bool 값으로 반환.(a b포함)
s2[s2.between(30, 50)]
```




    1     31
    7     45
    17    34
    19    37
    20    45
    23    50
    30    47
    34    37
    38    41
    41    37
    42    42
    46    33
    59    36
    60    38
    64    47
    69    35
    79    41
    83    41
    98    36
    99    38
    dtype: int32




```python
s2[~s2.between(30, 50)]
```




    0     28
    2     71
    3     64
    4     69
    5     16
          ..
    93    23
    94    16
    95     9
    96    54
    97    69
    Length: 80, dtype: int32



> - Series에서 
>     - 특정 조건이 True인 원소들을 조회:  boolean indexing
>     - 특정 조건이 True인 원소들의 index를 조회: numpy.where(boolean 연산)
>     - 특정 조건이 True인 원소와 False인 원소를 각각 다른 값으로 변경: numpy.where(boolean 연산, True변환값, False변환값)


> Numpy의 ndarray도 동일    

## 주요 메소드, 속성

![image.png](image.png)

![image.png](image.png)


```python
s2
```




    0     28
    1     31
    2     71
    3     64
    4     69
          ..
    95     9
    96    54
    97    69
    98    36
    99    38
    Length: 100, dtype: int32




```python
# 앞에 N개를 조회 (Default: 5)
print(s2.head())
print(s2.head(10))
```

    0    28
    1    31
    2    71
    3    64
    4    69
    dtype: int32
    0    28
    1    31
    2    71
    3    64
    4    69
    5    16
    6    20
    7    45
    8    29
    9    17
    dtype: int32



```python
# 뒤에 N개 조회 (Default: 5)
print(s2.tail()) 
print(s2.tail(10))
```

    95     9
    96    54
    97    69
    98    36
    99    38
    dtype: int32
    90    52
    91    94
    92    60
    93    23
    94    16
    95     9
    96    54
    97    69
    98    36
    99    38
    dtype: int32



```python
# 타입
print('타입:', s2.dtype) 
# 차별 크기
print('shape:', s2.shape) 
# 원소개수
print('원소개수:', s2.size) 
```

    타입: int32
    shape: (100,)
    원소개수: 100



```python
# 타입을 변경
## s2의 타입을 변경한 결과를 담는 새로운 Series를 반환. (deep copy)
s2.astype('float32')
```




    0     28.0
    1     31.0
    2     71.0
    3     64.0
    4     69.0
          ... 
    95     9.0
    96    54.0
    97    69.0
    98    36.0
    99    38.0
    Length: 100, dtype: float32




```python
# 원본 타입은 변경되지 않는다.
s2.dtype 
```




    dtype('int32')




```python
# 원본 타입을 변경할려면 s2 다시 넣어야된다
s2 = s2.astype('float32') 
```


```python
s2.dtype
```




    dtype('float32')




```python
s1 = pd.Series([10000,20000])
s1
```




    0    10000
    1    20000
    dtype: int64




```python
# 원본보다 작은 타입으로 줄일 때는 조심해야한다. 값이 깨진다.
s1.astype('int8') 
```




    0    16
    1    32
    dtype: int8




```python
# Unique값이 몇개있는지 세는 함수.
## index name : Unique값, value: 개수
s2.value_counts() 
```




    94.0    3
    26.0    3
    69.0    3
    99.0    3
    9.0     3
           ..
    53.0    1
    21.0    1
    42.0    1
    33.0    1
    23.0    1
    Name: count, Length: 66, dtype: int64




```python
### 카테고리의 분류를 할때 사용된다.
s5 = pd.Series(['컴퓨터','모니터','컴퓨터','컴퓨터','모니터','마우스','키보드','모니터'])
s5.value_counts() # Return 개수
```




    컴퓨터    3
    모니터    3
    마우스    1
    키보드    1
    Name: count, dtype: int64




```python
s5.value_counts(normalize=True) # 비율
# s5.value_counts()/s5.size
```




    컴퓨터    0.375
    모니터    0.375
    마우스    0.125
    키보드    0.125
    Name: proportion, dtype: float64




```python
# 고유값의 개수 반환
s5.nunique()
```




    4




```python
# 결측치(null)를 제외한 값의 개수
s2.count()
```




    100




```python
# 결측치값 : None, numpy.nan
s6 = pd.Series(['Python','C++',None,'C++','Python',None,'Java'])
```


```python
# 전체 원소의 개수 (결측치 포함)
print(s6.size)
```

    7



```python
# 결측치을 제외한 원소의 개수
print(s6.count())
```

    5



```python
# 결측치 개수는 세지않는다.
s6.value_counts()
```




    Python    2
    C++       2
    Java      1
    Name: count, dtype: int64



### 정렬
- **sort_values()**
    - 값으로 정렬
- **sort_index()**
    - index명으로 정렬
- 공통 매개변수
    - ascending=False (내림차순, 기본-True:오름차순)
    - inplace=True
        - 원본 자체를 정렬
        - False(기본값): 정렬결과를 새로운 Series로 반환.    
    - 결측치(NaN)는 정렬 방식과 상관없이 마지막에 나온다.


- sort_index(), sort_values() : return 값이 있다


```python
# index name 을 기준으로 정렬, 내림차순 (원본은바뀌지않는다.)
s6.sort_index(ascending=False) 
```




    6      Java
    5      None
    4    Python
    3       C++
    2      None
    1       C++
    0    Python
    dtype: object




```python
s6
```




    0    Python
    1       C++
    2      None
    3       C++
    4    Python
    5      None
    6      Java
    dtype: object




```python
# inplace = 원본 자체를 바꿈
s6.sort_index(ascending=False, inplace=True)
```


```python
s6
```




    6      Java
    5      None
    4    Python
    3       C++
    2      None
    1       C++
    0    Python
    dtype: object




```python
s6.value_counts()
```




    Python    2
    C++       2
    Java      1
    Name: count, dtype: int64




```python
s6.value_counts().sort_index()
```




    C++       2
    Java      1
    Python    2
    Name: count, dtype: int64




```python
# 값을 기준으로 정렬. Default - 오름차순 정령
s2.sort_values()
```




    55     5.0
    65     7.0
    66     7.0
    37     8.0
    21     9.0
          ... 
    50    96.0
    49    96.0
    57    99.0
    25    99.0
    53    99.0
    Length: 100, dtype: float32




```python
s2
```




    0     28.0
    1     31.0
    2     71.0
    3     64.0
    4     69.0
          ... 
    95     9.0
    96    54.0
    97    69.0
    98    36.0
    99    38.0
    Length: 100, dtype: float32




```python
s2.sort_values(ascending=False)
```




    25    99.0
    53    99.0
    57    99.0
    49    96.0
    50    96.0
          ... 
    21     9.0
    37     8.0
    65     7.0
    66     7.0
    55     5.0
    Length: 100, dtype: float32




```python
s2.sort_values(ascending=False, inplace=True)
```


```python
s2
```




    25    99.0
    57    99.0
    53    99.0
    49    96.0
    50    96.0
          ... 
    21     9.0
    37     8.0
    65     7.0
    66     7.0
    55     5.0
    Length: 100, dtype: float32



## 기술 통계량
- 데이터셋의 데이터들의 특징을 하나의 숫자로 요약한 것.
- ### 평균 
    - 전체 데이터들의 합계를 총 개수로 나눈 통계량
    - 전체 데이터셋의 데이터들은 평균값 근처에 분포되어 데이터셋의 대표값으로 사용한다.
    - 이상치(너무 크거나 작은 값)의 영향을 많이 받는다.


$$평균 = \cfrac{1}{n}\sum_{i=1}^{n}{X_i}$$
- ### 중앙값
    - 분포된 값들을 작은값 부터 순서대로 나열한 뒤 그 중앙에 위치한 값
    - 이상치에 영향을 받지 않아 평균대신 집단의 대표값으로 사용한다.
- ### 표준편차/분산
    - 값들이 흩어져있는 상태(분포)를 추정하는 통계량으로 분포된 값들이 평균에서 부터 얼마나 떨어져 있는지를 나타내는 통계량.
    - 각 데이터가 평균으로 부터 얼마나 차이가 있는지를 편차(Deviation)라고 한다. ($평균-데이터$)
    - 분산 : 편차 제곱의 합을 총 개수로 나눈 값 
    $$분산 = \cfrac{1}{n}\sum_{i=1}^{n}(평균-X_i)^2$$
    - 표준편차
        - 분산의 제곱근
        - 분산은 원래 값에 제곱을 했으므로 다시 원래 단위로 계산한 값.
        $$표준편차 = \sqrt{\cfrac{1}{n}\sum_{i=1}^{n}(평균-X_i)^2}$$

- ### 최빈값(mode)
    - 데이터 셋에서 가장 많이 있는 값.
- ### 분위수(Quantile)
    - 데이터의 크기 순서에 따른 위치값
        - 데이터셋을 크기순으로 정렬한뒤 N등분했을 때 특정 위치에서의 값 (단면)
        - N등분한 특정위치의 값들 통해 전체 데이터셋을 분포를 파악한다.
        - 대표적인 분위수 : 4분위, 10분위, 100분위
    - 데이터의 분포를 파악할 때 사용
    - 이상치 중 극단값들을 찾을 때 사용 (4분위수)
    <img src='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F99BCE04D5DF076AB2FA02D'>
    <img src='https://t1.daumcdn.net/cfile/tistory/99E6BD465DF0782433'>


```python
s = pd.Series([10,10,20,20,30,30,])
```


```python
# 평균
print(s.mean())
print('평균:',s.mean())
```

    20.0
    평균: 20.0



```python
s2 = pd.Series([10,10,20,20,30,30,1000])
```


```python
# 이상치가 있을때 평균을 대표값으로 쓰기 어렵다
s2.mean()
```




    160.0




```python
# 중앙값 : 오른차순으로 정렬후 중앙의 값을 대표값으로 사용
print(s2.median())
print('중앙값:', s2.median())
```

    20.0
    중앙값: 20.0



```python
# 분산
print(s.var())
print('분산:',s.var())
```

    80.0
    분산: 80.0



```python
# 표준편차
print(s.std())
print('표준편차:',s.std())
```

    8.94427190999916
    표준편차: 8.94427190999916



```python
s3 = pd.Series(list('aaaaaabcccbcbbccbbccbbcbabacbacbaaaa'))
```


```python
s3.nunique()
```




    3




```python
s3.value_counts()
```




    a    13
    b    12
    c    11
    Name: count, dtype: int64




```python
# 최빈값 : 빈도수(개수)가 제일 많은 값 - 범주형(분류기준으로 사용되는 값)
s3.mode() # Series로 반환.
```




    0    a
    dtype: object




```python
s.min(),s.max()
```




    (10, 30)




```python
# 최소값, 최대값이 있는지 index를 반환
s.idxmin(),s.idxmax() 
```




    (0, 4)




```python
# 합계
s.sum() 
```




    120




```python
# 여러 통계량을 묶어서 반환.
## 수치형 : count-결측치 제외한 값의 개수
s.describe()
```




    count     6.000000
    mean     20.000000
    std       8.944272
    min      10.000000
    25%      12.500000
    50%      20.000000
    75%      27.500000
    max      30.000000
    dtype: float64




```python
# 문자열 : Unique - 고유값의 개수(nunique()), top-최빈값(mode), freq: 최빈값의 개수
s3.describe()
```




    count     36
    unique     3
    top        a
    freq      13
    dtype: object




```python
# 분위수 
## q: 분위 0 ~ 1 실수
s2.quantile(q=0.5) 
```




    20.0




```python
# 10 분위의 1분위
s2.quantile(q=0.1) 
```




    10.0




```python
s2.quantile(q=[0.3, 0.7, 0.8])
```




    0.3    18.0
    0.7    30.0
    0.8    30.0
    dtype: float64




```python
s2.quantile(q=[0.25, 0.5, 0.75]) # 4분위
```




    0.25    15.0
    0.50    20.0
    0.75    30.0
    dtype: float64



## 결측치 (Missing Value, Not Available)
- 결측치
    - 모르는 값, 수집이 안된값, 현재 가지고 있지 않은 값.
- 판다스에서 결측치
    - None, numpy.nan, numpy.NAN
    - 결측치는 float 타입으로 처리된다.
    
### 결측치 확인
- 각 함수/메소드는 각 원소별로 결측치인지 확인해서 결과를 반환한다.
- Numpy
    - np.isnan(배열)
    
```python
import numpy as np
a = np.array([1,np.nan])
np.isnan(a)
```

- Series/DataFrame
    - Series/DataFrame객체.isnull() 또는 isna()
    - Series/DataFrame객체.notnull() 또는 notna()


```python
import pandas as pd
import numpy as np
```


```python
s = pd.Series([10,20,30, np.nan, 50, np.nan, 60])
```


```python
print('원소개수:', s.size)
```

    원소개수: 7



```python
print('결측치를 뺀 원소개수:', s.count())
```

    결측치를 뺀 원소개수: 5



```python
s.isnull() # 원소별로 결측치 인지 체크 ( 결측치 : True, 유효값 : False)
```




    0    False
    1    False
    2    False
    3     True
    4    False
    5     True
    6    False
    dtype: bool




```python
s.isna()
```




    0    False
    1    False
    2    False
    3     True
    4    False
    5     True
    6    False
    dtype: bool




```python
s.notnull() # 결측치 : false, 유효값 : True
```




    0     True
    1     True
    2     True
    3    False
    4     True
    5    False
    6     True
    dtype: bool




```python
s.notna()
```




    0     True
    1     True
    2     True
    3    False
    4     True
    5    False
    6     True
    dtype: bool




```python
# 결측치의 개수 
s.isnull().sum() # bool값들을 더할경우 : True - 1, False - 0으로 변환후 계산
```




    2




```python
# 결측치의 비율
s.isnull().mean()
```




    0.2857142857142857



### 결측치 처리
- 제거 
    - dropna()
- 다른값으로 대체 
    - fillna()
    - 평균, 중앙값, 최빈값을 주로 사용 


```python
s2 = s.copy()
```


```python
s2.dropna() # s2에서 결측치를 제거한 결과를 새로운 Series에 담아서 반환
```




    0    10.0
    1    20.0
    2    30.0
    4    50.0
    6    60.0
    dtype: float64




```python
s
```




    0    10.0
    1    20.0
    2    30.0
    3     NaN
    4    50.0
    5     NaN
    6    60.0
    dtype: float64




```python
s2.dropna(inplace=True)
```


```python
s2
```




    0    10.0
    1    20.0
    2    30.0
    4    50.0
    6    60.0
    dtype: float64




```python
s2.iloc[3]
```




    50.0




```python
s
```




    0    10.0
    1    20.0
    2    30.0
    3     NaN
    4    50.0
    5     NaN
    6    60.0
    dtype: float64




```python
s.fillna(10000)
```




    0       10.0
    1       20.0
    2       30.0
    3    10000.0
    4       50.0
    5    10000.0
    6       60.0
    dtype: float64




```python
# 결측치를 대체 : 가장 가능성이 높은 값으로 채움 -> 수치 : 평균, 중앙값 범주 : 최빈값
```


```python
# 결측치를 제거하고 계산.
m = s.mean()
```


```python
m
```




    34.0




```python
# 평균값으로 채움
s.fillna(m)
```




    0    10.0
    1    20.0
    2    30.0
    3    34.0
    4    50.0
    5    34.0
    6    60.0
    dtype: float64

