---
layout: single
title: '변수와 연산자'
typora-root-url: ../
categories: OpenCv.02.기본영상처리
tag: OpenCv
toc: true
---

# 히스토그램
- 영상을 구성하는 픽셀들의 빈도수를 측정하여 그래프(히스토그램)으로 표현

- **`cv2.calcHist(images, channels, mask, histSize, ranges, hist=None, accumulate=None)`**
    - images: 히스토그램을 구할 입력영상 리스트
    - channels: 히스토그램을 구할 채널 리스트
    - mask: 마스크 영상. 영상전체일 경우 None지정
    - histSize: 히스토그램 각 채널의 bin의 개수 리스트. 여기서는 각각의 픽셀값을 셀 것이므로 255개로 지정
    - ranges: 히스토그램을 이용해 빈도수를 셀 최솟값과 최대값을 리스트로 설정. [0, 256] 0 ~ 255 (마지막은 포함 안함)

### Grayscale 영상의 히스토그램 구하기


```python
import cv2
import matplotlib.pyplot as plt
import numpy as np
```


```python
img = cv2.imread('images/window.jpg', cv2.IMREAD_GRAYSCALE)
plt.imshow(img, cmap='gray');
```


![output_4_0](/../../../Hinya - Github/images/2023-10-13-00.기본 영상처리/output_4_0.png)
    



```python
hist = cv2.calcHist([img],    # pixcel값의 분표를 계산할 이미지 ( ndarray)
                    [0],      # pixcel값의 분표를 계산할 채널
                    None,     # pixcel값의 분포를 계산할 영역. 전체영역: None
                    [256],    # bins: 몇계급으로 나눌지
                    [0, 256]) # 빈도수를 셀 pixcel값의 범위


```


```python
print(type(hist))
print(hist.shape ) # index: pixcel값, value: 값
```

    <class 'numpy.ndarray'>
    (256, 1)



```python
hist[0], hist[100]
```




    (array([0.], dtype=float32), array([1036.], dtype=float32))




```python
# Hist
import numpy as np

plt.bar(np.arange(hist.size), hist.flatten())
plt.xlabel('픽셀값')
plt.ylabel('개수')
plt.show()
```


![output_7_0](/../../../Hinya - Github/images/2023-10-13-00.기본 영상처리/output_7_0.png)
    



```python

```

### 컬러영상의  히스토그램 구하기
- channel 별로 그린다.


```python
lenna = cv2.imread('images/lenna.png')
print(lenna.shape)
```

    (512, 512, 3)



```python
# BGR
blue = lenna[:, :, 0]
green = lenna[:, :, 1]
red = lenna[:, :, 2]

print(blue.shape, green.shape, red.shape)
```

    (512, 512) (512, 512) (512, 512)



```python
bgr = cv2.split(lenna) # 채널별로 나눠진 배열들을 튜플로 묶어서 반환
print(type(bgr), len(bgr))
```

    <class 'tuple'> 3



```python
color_labels = ['blue', 'green', 'red']

for channel, color in zip(bgr, color_labels):
    hist = cv2.calcHist([channel], [0], None, [256], [0, 256])
    plt.plot(np.arange(hist.size), hist.flatten(), color=color)

plt.xlabel('픽셀값')
plt.ylabel('개수')
plt.show()

```


![output_13_0](/../../../Hinya - Github/images/2023-10-13-00.기본 영상처리/output_13_0.png)
    





# 밝기 조절하기(brightness)
- 영상을 전체적으로 밝게 또는 어둡게 만드는 연산
- 밝기 조절 수식
    - 원본좌표(x,y) + n
    - n이 양수면 각 좌표의 픽셀값이 커지므로 밝아진다.
    - n이 음수이면 각 좌표의 픽셀값이 작아지므로 어두워 진다.
    
- **`cv2.add(src1, src2)`**
    - 밝기 조절이나 두 영상을 합치기에 사용할 수 있다.
    - src1: 첫번째 영상 또는 스칼라
    - src2: 두번째 영상 또는 스칼라
    - src2를 src1에 더한다.
- pixel에 스칼라 값을 더하거나 빼면 0 ~ 255의 범위를 넘어설 수 있다. ndarray의 type은 uint8(unsigned int8) 로 0 ~ 255범위를 넘어가는 숫자는 순환되어 버린다. 
    - 계산결과가 0이하가 되면 255로 부터 작아지게 되고 255가 넘어가면 0으로 가서 커지게 된다.
    - 그래서 cv2.add() 함수는 값이 순환되지 않도록 0이하의 값은 0으로 255이상의 값은 255가 되도록 처리한다. 이것을 **saturate연산**이라고 한다.


```python
import cv2
import numpy as np
```


```python
img = cv2.imread('images/penguin.jpg', cv2.IMREAD_GRAYSCALE)
result1 = img - 100 # 어둡게
result2 = img + 100 # 밝게
```


```python
cv2.imshow('src', img)
cv2.imshow('result1', result1)
cv2.imshow('result2', result2)

cv2.waitKey()
cv2.destroyAllWindows()
```


```python
hist1 = cv2.calcHist([img], [0], None, [256], [0, 256])
hist2 = cv2.calcHist([result1], [0], None, [256], [0, 256])

plt.plot(hist1.flatten(), label='원본')
plt.plot(hist2.flatten(), label='-100')

plt.legend(bbox_to_anchor=(1,1), loc='upper left')
plt.show()
```

    C:\Users\world\anaconda3\Lib\site-packages\IPython\core\pylabtools.py:152: UserWarning: Glyph 50896 (\N{HANGUL SYLLABLE WEON}) missing from current font.
      fig.canvas.print_figure(bytes_io, **kw)
    C:\Users\world\anaconda3\Lib\site-packages\IPython\core\pylabtools.py:152: UserWarning: Glyph 48376 (\N{HANGUL SYLLABLE BON}) missing from current font.
      fig.canvas.print_figure(bytes_io, **kw)




![output_19_0](/../../../Hinya - Github/images/2023-10-13-00.기본 영상처리/output_19_0.png)
    



```python
# saturation 연산

img = cv2.imread('images/penguin.jpg', cv2.IMREAD_GRAYSCALE)
result1 = cv2.add(img, -100) # 어둡게
result2 = cv2.add(img, +100) # 밝게

cv2.imshow('src', img)
cv2.imshow('result1', result1)
cv2.imshow('result2', result2)

cv2.waitKey()
cv2.destroyAllWindows()
```


```python
hist1 = cv2.calcHist([img], [0], None, [256], [0, 256])
hist2 = cv2.calcHist([result1], [0], None, [256], [0, 256])
hist3 = cv2.calcHist([result2], [0], None, [256], [0, 256])

plt.plot(hist1.flatten(), label='원본')
plt.plot(hist2.flatten(), label='-100')
plt.plot(hist3.flatten(), label='+100')

plt.legend(bbox_to_anchor=(1,1), loc='upper left')
plt.show()
```


![output_21_0](/../../../Hinya - Github/images/2023-10-13-00.기본 영상처리/output_21_0.png)
    



```python
# bool < uint < int < float < str
img - 100.0 # uint8 - float64 ==> float64 - float64
```


```python
# saturation 연산 - numpy 함수이용

img = cv2.imread('images/penguin.jpg', cv2.IMREAD_GRAYSCALE)

# 1. img(uint type) -> float type 변환후 계산 
# 2. np.clip() , 0 ~ 255 범위 지정
# 3. float type -> uint8 type

result1 = np.clip(img-100.0, 0, 255).astype('uint8') # 어둡게
result2 = np.clip(img+100.0, 0, 255).astype('uint8') # 밝게


cv2.imshow('src', img)
cv2.imshow('result1', result1)
cv2.imshow('result2', result2)

cv2.waitKey()
cv2.destroyAllWindows()
```


```python
# 두 이미지 합치기
lenna_gray = cv2.imread('images/lenna.png', cv2.IMREAD_GRAYSCALE)
img2 = cv2.resize(img, (512, 512))

# image + image = 두이미지를 합침 -> element-wise 연상
result = cv2.add(lenna_gray, img2) 

cv2.imshow('result', result)
cv2.waitKey()
cv2.destroyAllWindows()
```


```python
# 컬러이미지 밝기 조절 -> HSV 색공간으로 변환. H: 색, S: 채도, V: 명암
lenna = cv2.imread('images/lenna.png')
lenna_hsv1 = cv2.cvtColor(lenna, cv2.COLOR_BGR2HSV)
lenna_hsv2 = cv2.cvtColor(lenna, cv2.COLOR_BGR2HSV)

lenna_hsv1[:, :, 2] = cv2.add(lenna_hsv[:, :, 2], -100)
lenna_hsv2[:, :, 2] = cv2.add(lenna_hsv[:, :, 2], +100)

cv2.imshow('src', lenna)
cv2.imshow('result1', cv2.cvtColor(lenna_hsv1, cv2.COLOR_HSV2BGR)) # 어둡게
cv2.imshow('result2', cv2.cvtColor(lenna_hsv2, cv2.COLOR_HSV2BGR)) # 밝게

cv2.waitKey()
cv2.destroyAllWindows()
```


```python
# BGR 모드에서 덧셈처리
# channel이 있는경우 -> 채널별로 계산 (0, 1, 2, 3)
#                        상수를 지정한 경우: 0번 channel에만 계산
result1 = cv2.add(lenna, (100, 100, 100, 0) )     # 밝게
result2 = cv2.add(lenna, (-100, -100, -100, 0) )  # 어둡게

cv2.imshow('src', lenna)
cv2.imshow('result1', result1)
cv2.imshow('result2', result2)
cv2.waitKey()
cv2.destroyAllWindows()
```



# 명암비(Contrast) 조정

## 명암비/대비(Contrast)란
- 밝은 부분과 어두분 부분 사이의 밝기의 정도 차이
    - 영상이 전체적으로 밝은 픽셀들로만 구성되거나 어두운 픽셀들로만 구성되면 명암비가 낮다고 표현한다. 
    - 영상에 밝은 영역과 어두운 영역이 골고루 섞여있으면 명암비가 높다고 표현한다.
- 명암비가 낮으면 객체간의 구분이 되지 않아 흐릿한 느낌이 나고 명암비가 높으면 선명한 느낌이 든다.

- 명암비를 변환하는 함수공식
$$
g(x, y)=f(x,y)+(f(x,y)-128) \alpha\\
==\\
(1+\alpha)f(x, y)-\alpha 128
$$

- $g$는 결과 image
- $f$는 원본 image
- $x$: x좌표
- $y$: y좌표
- $\alpha$: 대비를 조절하는 값. 
    - 0: 원본과 동일
    - 음수: 명암비를 낮춘다.
    - 양수: 명암비를 높인다.


```python
# 명암비 -> 함수를 만들어야된다.
def control_contrast(img, alpha=0.0):
    return np.clip((1.0 + alpha)*img - alpha*128, 0, 255).astype('uint8')
```


```python
a1 = np.arange(256)
a2 = control_contrast(a1, alpha=-0.5)
a3 = control_contrast(a1, alpha=1.5)
```


```python
plt.plot(a1, linestyle=':', label='0')
plt.plot(a2, label='0.5')
plt.plot(a3, label='1.5')

plt.legend(title='alpha', bbox_to_anchor=(1, 1), loc='upper left')
plt.show()
```


![output_31_0](/../../../Hinya - Github/images/2023-10-13-00.기본 영상처리/output_31_0.png)
    



```python
# gray scale
lenna_gray = cv2.imread('images/lenna.png', cv2.IMREAD_GRAYSCALE)

# color
lenna_gray = cv2.imread('images/lenna.png')[:, :, ::-1]

result1 = control_contrast(lenna_gray, -0.5)
result2 = control_contrast(lenna_gray, 1.0)
```


```python
plt.figure(figsize=(15, 5))

plt.subplot(1, 3, 1)
plt.imshow(lenna_gray, cmap='gray')
plt.title('원본')
plt.axis('off')

plt.subplot(1, 3, 2)
plt.imshow(result1, cmap='gray')
plt.title('-0.5')
plt.axis('off')

plt.subplot(1, 3, 3)
plt.imshow(result2, cmap='gray')
plt.title('1.0')
plt.axis('off')

plt.tight_layout()
plt.show()
```


![output_33_0](/../../../Hinya - Github/images/2023-10-13-00.기본 영상처리/output_33_0.png)
    





## 채도 (Saturation) 변환
- 채도: 색의 선명도를 말한다.
- 채도를 변환할 때는 HSV color 타입으로 변환한 뒤 S의 값을 바꾼다.
> HSV : 색상(Hue), 채도(Saturation), 명도(Value)


```python
lenna = cv2.imread('images/lenna.png')
lenna_hsv = cv2.cvtColor(lenna, cv2.COLOR_BGR2HSV)

value = 50

lenna_hsv[:, :, 1] = cv2.add(lenna_hsv[:, :, 1], value)
```


```python
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.imshow(cv2.cvtColor(lenna, cv2.COLOR_BGR2RGB))
plt.title('원본')

plt.subplot(1, 2, 2)
plt.imshow(cv2.cvtColor(lenna_hsv, cv2.COLOR_HSV2RGB))
plt.title(f'{value}')

plt.tight_layout()
plt.show()
```


![output_37_0](/../../../Hinya - Github/images/2023-10-13-00.기본 영상처리/output_37_0.png)
    





# Filter 

## Blurring

- 영상을 흐릿/부드럽게 만드는 작업.
- 픽셀간의 값의 차이를 줄여서 날카로운 엣지가 무뎌지고 영상에 있는 Noise(잡음)이 사라지도록 하는 효과가 있다.
> 엣지(Edge): 물체간의 경계부분으로 contrast(대비)가 크다.

### 평균값 블러링(Average Blur)

- 주변 픽셀의 평균값을 합성곱하여 적용한다.
- 보통 3 x 3이나 5 x 5 필터를 많이 쓰며 필터의 크기가 커질수록 더 흐릿하게 변환된다.
- 영상이 뭉게져 세밀한 부분이 잘 안보이는 단점이 있다.

<center>필터 예</center>

- **`cv2.blur(src, ksize)`**
    - src: blur 처리할 입력영상
    - ksize: 필터의 크기. (width, height) 튜플로 지정


```python
import cv2
import numpy as np
import matplotlib.pyplot as plt
```


```python
lenna = cv2.imread('images/lenna.png')
```


```python
lenna_blur1 = cv2.blur(lenna, (3, 3)) # 3 X 3: 모든 값이 9/1
lenna_blur2 = cv2.blur(lenna, (5, 5)) # 5 X 5: 1/25

cv2.imshow('src', lenna)
cv2.imshow('result', lenna_blur1)
cv2.imshow('result1', lenna_blur2)

cv2.waitKey()
cv2.destroyAllWindows()
```


```python
# Noise 감소 확인
# Noise는 Pixcel 값에 차이가 큰 픽셀이 중간 중간 겨있는 상태
# 200, 200, 5, 200, 10, 200, 200
```


```python
plt.figure(figsize=(15, 3))
plt.plot(lenna[30, :, 2]) 

plt.show()
```


​    
![png](output_48_0.png)
​    



```python
plt.figure(figsize=(15, 3))
plt.plot(lenna_blur[30, :, 2]) 

plt.show()
```


​    
![png](output_49_0.png)
​    



```python
# Filter2D() 함수이용 => 직접 Filter를 전달해서 Convolution 연산처리
```


```python
# 3 X 3 필터
## kernel = np.ones(shape=(3, 3)) / 9

# 7 X 7 필터
kernel = np.ones(shape=(7, 7)) / 49
result = cv2.filter2D(lenna, -1, kernel)

cv2.imshow('result', result)

cv2.waitKey()
cv2.destroyAllWindows()
```



### Gaussian Blur

- 대상 픽셀(Anchor)와 가까운 픽셀은 큰 가중치 멀리있는 픽셀은 작은 가중치를 사용해서 평균(가중평균)을 계산해서 필터링 한다.

    
- Gaussian Blurring은 blur효과 뿐아니라 노이즈제거에도 많이 사용된다.

- **GaussianBlur Filter의 형태**

- **`cv2.GaussianBlur(src, ksize, sigmaX, sigmaY)`**
    - src: blur를 적용할 영상. 
    - ksize: 커널크기. (0,0)으로 지정하면 sigma 값에 의해 결정된다. (보통 0,0 으로 설정)
    - sigamX: X축방향 sigma(표준편차) 값
    - sigamY: Y축방향 sigma(표준편차) 값. 생략하면 sigmaX와 같은 값 사용



```python
lenna = cv2.imread('images/lenna.png')
lenna_gb = cv2.GaussianBlur(lenna, 
                            ksize=(0, 0), # 커널(필터) 크기: (0, 0) -> 표준편차에 크기에 맞춰 크기를 정한다.
                            sigmaX = 1,   # 커널크기: (W, H) => Width 표준편차
                            sigmaY = 1    # Height 표준편차. -> 생략시 sigmaX와 동일 값
                           )
# 표준편차를 크게 할수록 필터 크기가 커진다. -> 커지면 blur 효과가 강해진다
cv2.imshow('src', lenna)
cv2.imshow('src1', lenna_gb)

cv2.waitKey()
cv2.destroyAllWindows()
```



### 잡음 제거
- `cv2.bilateralFilter(src, d, sigmaColor, sigmaSpace)`
    - 양방향 필터로 선명도는 유지하면서 bluring을 이용해 노이즈를 제거한다.
    - src: 잡음을 제거할 입력영상
    - d: 필터의 크기 지정(가우시안 blur의 ksize). 음수(-1)을 입력하면 sigmaSpace값에 의해 자동 결정된다. 일반적으로 -1을 설정한다.
    - sigmaColor
        - 엣지인지 아닌지를 판단하는 기준값 설정. pixcel간의 차이가 지정한 값보다 크면 엣지라고 생각하고 작으면 엣지가 아니라고 생각해 그 지점을 blurring 한다.
        - 이 값을 너무 크게 주면 엣지가 검출이 안되서 그냥 Gaussian Filter 사용하는 것과 같다.
    - sigmaSpace: Gaussian Filter에서 지정한 표준편차


```python
import cv2 
import matplotlib.pyplot as plt
```


```python
sigma = 10
sigmaColor = 30
lenna_bf = cv2.bilateralFilter(lenna, 
                               d = -1,                  # Filter크기를 표준편차로 결정
                               sigmaColor = sigmaColor, # 엣지로 판단할 Pixcel값의 차이
                               sigmaSpace = sigma       # 표준편차
                              )
```


```python
plt.figure(figsize=(15, 7))
plt.subplot(1, 2, 1)
plt.imshow(lenna[:, :, ::-1])

plt.subplot(1, 2, 2)
plt.imshow(lenna_bf[:, :, ::-1])
plt.title(f'잡음제거: sigma={sigma}')
plt.tight_layout()
plt.show()
```


​    
![png](output_61_0.png)
​    



```python
plt.figure(figsize=(20, 6))

plt.subplot(2, 1, 1)
plt.plot(lenna[30, :, 0])

plt.subplot(2, 1, 2)
plt.plot(lenna_bf[30, :, 0])

plt.show()
```


​    
![png](output_62_0.png)
​    





## 샤프닝(Sharpen)
- Blurring의 반대로 흐린영상을 선명한 영상으로 만드는 작업.
- 선명한 영상을 만들기 위해서는 이미지의 엣지(edge-사물의 윤곽부분)의 대비를 크게 만들어 준다.

$$
h(x) = f(x)+\alpha(f(x)-\bar{f}(x))\\
f(x): 원본\;이미지\\
\bar{f}(x):\;원본\;이미지를\;blurring한\;이미지\\
\alpha: shappening 정도\,조절값
$$

- 제공 함수는 없고 위 공식을 구현한다.
    - `addWeighted(src, src_가중치, src2, src2_가중치, 더해줄값)`
        - 가중합 계산 함수
        - $src\times src가중치 + src2\times src2가중치 + 더해줄값$


```python
import cv2
import matplotlib.pyplot as plt
import numpy as np
```


```python
def sharppen(src_img, alpha=0.0):
    # 원본 + (원본 - 블러) * alpha
    # blur -> 가우시안 블러
    src_blur = cv2.GaussianBlur(src_img, (0, 0), 1)
    src_img = src_img.astype('float64')
    return np.clip(src_img + (src_img - src_blur) * alpha, 0, 255).astype('uint8')
```


```python
rose = cv2.imread('images/rose.bmp')
rose_1 = sharppen(rose, 1)
rose_2 = sharppen(rose, 2)
rose_3 = sharppen(rose, 3)
```


```python
plt.figure(figsize=(10, 10))

plt.subplot(2, 2, 1)
plt.imshow(rose[:, :, ::-1])
plt.title('원본')

plt.subplot(2, 2, 2)
plt.imshow(rose_1[:, :, ::-1])
plt.title('alpha 1')

plt.subplot(2, 2, 3)
plt.imshow(rose_2[:, :, ::-1])
plt.title('alpha 2')

plt.subplot(2, 2, 4)
plt.imshow(rose_3[:, :, ::-1])
plt.title('alpha 3')

plt.tight_layout()
plt.show()
```


​    
![png](output_70_0.png)
​    



```python
def sharppen2(src_img, alpha=0.0):
    src_blur = cv2.GaussianBlur(src_img, (0, 0), 1)
    return cv2.addWeighted(src_img, (1+alpha), src_blur, -alpha, 0)
```


```python
rose = cv2.imread('images/rose.bmp')
rose_1 = sharppen2(rose, 1)
rose_2 = sharppen2(rose, 2)
rose_3 = sharppen2(rose, 3)
```


```python
plt.figure(figsize=(10, 10))

plt.subplot(2, 2, 1)
plt.imshow(rose[:, :, ::-1])
plt.title('원본')

plt.subplot(2, 2, 2)
plt.imshow(rose_1[:, :, ::-1])
plt.title('alpha 1')

plt.subplot(2, 2, 3)
plt.imshow(rose_2[:, :, ::-1])
plt.title('alpha 2')

plt.subplot(2, 2, 4)
plt.imshow(rose_3[:, :, ::-1])
plt.title('alpha 3')

plt.tight_layout()
plt.show()
```


​    
![png](output_73_0.png)
​    



