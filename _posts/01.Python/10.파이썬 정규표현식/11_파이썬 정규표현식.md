```python
s = "aaaabcccddedf 010-1111-2222 klaksdfjlkasdfjl"
# 010-1111-2222 있는지 여부
"010-1111-2222" in s
```




    False




```python

# 010-1111-2222 다른 문자열로 변환
s.replace("010-1111-2222", "전화번호")
s.replace("2222", "XXXX")
```




    'aaaabcccddedf 010-1111-3333 klaksdfjlkasdfjl'



# <font size=50>정규 표현식 (Regular Expression)</font>

# 정규 표현식(Regular Expression) 개요

## 정규 표현식이란
- 텍스트에서 특정한 형태나 규칙을 가지는 문자열을 찾기 위해 그 형태나 규칙을 정의하는 것.
- 파이썬 뿐만 아니라 문자열을 다루는 모든 곳에서 사용된다.
- **정규식, Regexp**이라고도 한다.

## 기본개념
- **패턴** 
    - 정규 표현식이라고 한다.
    - 문장내에서 찾기위한 문구의 형태에 대한 표현식.
- **메타문자**
    - 패턴을 기술하기 위해 사용되는 특별한 의미를 가지는 문자
    - 예) `a*` : a가 0회 이상 반복을 뜻한다. a, aa, aaaa
- **리터럴**
    - 표현식이 값 자체를 의미하는 것
    - 예) `a`는 `a` 자체를 의미한다.    

# 정규 표현식 메타 문자
- 패턴을 기술하기 위한 문자

## 문자 클래스 :  [  ]
- `[ ]` 사이의 문자들과 매칭
    - `[abc]` : a, b, c 중 **하나의 문자**와 매치
- `-`를 이용해 범위로 설정할 수 있다.
    - `[a-z]` : 알파벳소문자중 하나의 문자와 매치
    - `[a-zA-Z0-9]` : 알파벳대소문자와 숫자 중 하나의 문자와 매치
    - `[가-힣ㄱ-ㅎㅏ-ㅣ]`: 한글중 하나와 매치
- `[^ 패턴]` : ^ 으로 시작하는 경우 반대의 의미
    - `[^abc]` : a, b, c를 제외한 나머지 문자들 중 하나와 매치.
    - `[^a-z]` : 알파벳 소문자를 제외한 나머지 문자들 중 하나와 매치

## 미리 정의된 문자 클래스
- 자주 사용되는 문자클래스를 미리 정의된 별도 표기법으로 제공한다.
- `\d` : 숫자와 매치. [0-9]와 동일
- `\D` : `\d`의 반대. 숫자가 아닌 문자와 매치.  [^0-9]와 동일
- `\w` : 문자와 숫자, _(underscore)와 매치. `[a-zA-Z가-힣0-9_]`와 동일  (문자는 특수문자 제외한 일반문자-언어상관없는-들을 말한다.
- `\W` : `\w`의 반대. 문자와 숫자와 _ 가 아닌 문자와 매치.  `[^a-zA-Z가-힣0-9_]`와 동일
- `\s` : 공백문자와 매치. tab,줄바꿈,공백문자와 일치
- `\S` : `\s`와 반대. 공백을 제외한 문자열과 매치.
- `\b` : 단어 경계(word boundary) 표시. 단어와 단어 구분자. 보통 단어 경계로 빈문자열
    - 단어경계: 공백, `.`, `-`, `,` 등
    - `\b가족\b` => 우리 가족 만세(O), 우리가족만세 (X)
- `\B` : `\b`의 반대. 단어 경계로 구분된 단어가 아닌 경우
    - `\B가족\B` => 우리 가족 만세(X), 우리가족만세 (O)

## 글자수와 관련된 메타문자
- `*` : 앞의 문자(패턴)과 일치하는 문자가 0개 이상인 경우. (`a*b`)
- `+` : 앞의 문자(패턴)과 일치하는 문자가 1개이상인 경우.  (`a+b`)
- `?` :  앞의 문자(패턴)과 일치하는 문자가 한개 있거나 없는 경우. (`a?b`)
- `{m}` : 앞의 문자(패턴)가 m개. (`a{3}b`)
- `{m,}` : 앞의 문자(패턴)이 m개 이상. (`a{3,}b`)
    - , 뒤에 공백이 들어오지 않도록 한다.
- `{m,n}` : 앞의 문자(패턴)이 m개이상 n개 이하. (`a{2,5}b`)    
- `.`, `*`, `+`, `?` 를 리터럴로 표현할 경우 `\`를 붙인다.

## 문장의 시작과 끝 표현
- `^` 문자열의 시작 (`^abc`)
    - 문자 클래스([ ])의 ^와는 의미가 다르다.
- `$` : 문자열의 끝 (`abc$`)

## 기타
- `.` : 한개의 모든 문자(\n-줄바꿈 제외) (`a.b`)
- `|` : 둘중 하나(OR) (?:010|011|016|019)
    - 010|016-111 : 010 또는 016-111 이 된다. 
- `(  )` : 패턴내 하위그룹을 만들때 사용

# re 모듈
- 파이썬에서 정규 표현식을 지원하기 위한 모듈
- 파이썬 기본 라이브러리

## 코딩패턴
- 모듈 import
    - import re
1. 객체지향형
    - 패턴 객체를 생성후 메소드를 호출해 원하는 처리를 한다.
     ```python
        p = re.compile(r'\d+')
        p.search('abc123def')
    ```
2. 함수형
    - `re` 모듈의 원하는 작업을 하는 함수를 호출한다. Argument로 패턴과 처리할 값을 전달한다.
    ```python
        re.search(r'\d+', 'abc123def')
    ```
    
> ### raw string
> - 패턴문자중 `\`로 시작하는 것들을 사용할 경우 `escape` 문자와의 구분을 위해 `\\` 두개씩 작성해야한다.  그래서 패턴을 지정할 때는 raw string을 사용하는 것이 편리하다.
>    - `re.compile('\b가족\b')` : `\b`를 escape 문자 b(백스페이스)로 인식
>    - `re.compile(r'\b가족\b')` : `\b`가 일반문자가 되어 컴파일시 정규식 메타문자로 처리된다.


## 검색함수
- match(), search() : 패턴과 일치하는 문장이 **있는지 여부**를 확인할 때 사용
- findall() : 패턴과 일치하는 문장을 **찾을 때** 사용

### Match 객체
- **검색 결과를** 담아 반환되는 객체
    - match(), search() 의 반환타입
- 패턴과 일치한 문자열과 대상문자열 내에서의 위치를 가지고 있는 객체
- 주요 메소드
    - **group()** : 매치된 문자열들을 튜플로 반환
    - **group(subgroup 번호)** : 패턴에 하위그룹이 지정된 경우 특정 그룹의 문자열 반환
    - **start(), end()** : 대상 문자열내에서 시작, 끝 index 반환
    - **span()** : 대상 문자열 내에서 시작, 끝 index를 tuple로 반환

### match(대상문자열 [, pos=0])
- 대상 문자열의 시작 부터 정규식과 일치하는 것이 있는지 조회
- pos : 시작 index 지정
- 반환값
    - Match 객체: 일치하는 문자열이 있는 경우
    - None: 일치하는 문자열이 없는 경우


```python
import re

# txt = "안녕하세요. 반갑습니다. 제 나이는 20세입니다."
txt = "반갑습니다. 안녕하세요. 제 나이는 20세입니다."

# 객체지향 방식 -> Pattern객체를 생성한 뒤 그 메소드를 이용해 패턴의 대상문자열들을 처리.
## 1. 패턴 객체를 생성
p = re.compile(r"\w*하세요")  #\w{2} - 일반문자, 숫자, _ 두글자
print(type(p))
result = p.match(txt) # txt가 p의 패턴으로 시작하는지 여부
if result is not None: # 찾았으면
    print(type(result))
    print(result)
    print("위치(index):", result.span())
    print(f"시작위치: {result.start()}, 종료위치(index): {result.end()}")
    print(f"찾은 문자열: {result.group()}")
else:
    print(result)
    print("지정한 패턴으로 시작하지 않는 문자열입니다.")
```

    <class 're.Pattern'>
    <class 're.Match'>
    <re.Match object; span=(0, 5), match='안녕하세요'>
    위치(index): (0, 5)
    시작위치: 0, 종료위치(index): 5
    찾은 문자열: 안녕하세요
    


```python
txt = "안녕하세요. 반갑습니다. 제 나이는 20세입니다."
txt = "반갑습니다. 안녕하세요. 제 나이는 20세입니다."

## 함수를 이용한 방식
#re모듈의 match()함수를 호출 ==> Pattern객체의 match()메소드와 동일한 기능
result = re.match(r"\w{2}하세요", txt)   #(패턴, 대상문자열)
print(result)
if result:
    print(result.group())
else:
    print("찾는 패턴으로 시작하지 않습니다.")
```

    None
    찾는 패턴으로 시작하지 않습니다.
    

### search(대상문자열 [, pos=0])
- 대상문자열 전체 안에서 정규식과 일치하는 것이 있는지 조회
- pos: 찾기 시작하는 index 지정
- 반환값
    - Match 객체: 일치하는 문자열이 있는 경우
    - None: 일치하는 문자열이 없는 경우|


```python
txt = "반갑습니다. 안녕하세요. 제 나이는 20세입니다."
txt = "반갑습니다. 안녕하세요. 제 나이는 20세입니다. 30 40, 50"
pattern = r"\d{2}"  #숫자 두개

result = re.match(pattern, txt)
print(result)

# 전체 문장 안에 패턴이 있는지 확인. (다 찾지 않는다. 첫번째 것을 찾으면 더이상 찾지 않음.)
result2 = re.search(pattern, txt)  
print(result2)
print(txt[result2.start()])
```

    None
    <re.Match object; span=(20, 22), match='20'>
    2
    


```python
txt = "가격은 400, 5000, 15000원 입니다."
# p = re.compile(r"\d+") # 숫자 1개 이상이 연결.
# p = re.compile(r"\d{5}") # 숫자 5개가 연결. -> 만단위 정수
p = re.compile(r"\d{4,7}") # 숫자가 4개이상 7개 이하 연결 -> 천 ~ 백만단위

result = p.search(txt)
if result:
    print(result)
    print(result.group())
    print(result.span())
else:
    print("찾는 패턴이 없습니다.")
```

    <re.Match object; span=(9, 13), match='5000'>
    5000
    (9, 13)
    

### findall(대상문자열)
- 대상문자열에서 정규식과 매칭되는 문자열들을 리스트로 반환
- 반환값
    - 리스트(List) : 일치하는 문자열들을 가진 리스트를 반환
    - 일치하는 문자열이 없는 경우 빈 리스트 반환


```python
txt = "가격은 400, 5000, 15000원 입니다. 물건은 각각 10, 20, 100개 있습니다."

p = re.compile(r"\d+")
# p = re.compile(r"\d{10}")  # 패턴의 문장이 없을 경우 빈리스트반환.
result = p.findall(txt)
print(type(result))
print(result)
```

    <class 'list'>
    []
    


```python
# finditer(대상문자열) -> 찾은 결과를 조회할 수 있는 Iterator를 반환.
## Iterator는 각 결과를 Match객체로 반환한다.
txt = "가격은 400, 5000, 15000원 입니다. 물건은 각각 10, 20, 100개 있습니다."
p = re.compile(r"\d+")
result = p.finditer(txt)
print(type(result))

for match in result:
    print(match)
```

    <class 'callable_iterator'>
    


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    Cell In[41], line 8
          6 print(type(result))
          7 next(result)
    ----> 8 result[2]
    

    TypeError: 'callable_iterator' object is not subscriptable


# 연습문제

- info 변수는 한줄에 한사람의 data가 있고 구성은 **`이름 이메일주소 주민번호`** 순서로 되어있다.


```python
info ='''김정수 kjs@gmail.com 801023-0102212
박영수 pys.abc@gmail.com 700121-1120212
이민영 lmy-abc@naver.com 820301-2020122
김순희 ksh@daum.net 781223-2012212
오주연 ojy@daum.net 900522-1023218
'''
```


```python
# Email 주소만 추출 해서 출력
email_pattern = r"\b[\w\.-]+@[\w\.-]+\.\w{2,4}\b"
p = re.compile(email_pattern)
result = p.findall(info)
print(result)
```

    ['kjs@gmail.com', 'pys.abc@gmail.com', 'lmy-abc@naver.com', 'ksh@daum.net', 'ojy@daum.net']
    


```python
# 주민번호들만 조회해서 출력
pattern = r"\d{6}-\d{7}"
pattern = r"\d{6}-[012349]\d{6}"
p = re.compile(pattern)
result = p.findall(info)
print(result)
```

    ['801023-1010221', '700121-1120212', '820301-2020122', '781223-2012212', '900522-1023218']
    


```python
pattern = r"[가-힣]{2,4}"
p = re.compile(pattern)
# result = p.findall(info)
# print(result)
result = p.finditer(info)
for name in result:
    print(name)
```

    <re.Match object; span=(0, 3), match='김정수'>
    <re.Match object; span=(31, 34), match='박영수'>
    <re.Match object; span=(67, 70), match='이민영'>
    <re.Match object; span=(104, 107), match='김순희'>
    <re.Match object; span=(136, 139), match='오주연'>
    

### finditer(대상문자열)
- 패턴에 일치하는 모든 문자열을 찾아주는 Iterator => for문, list()
- 찾은 문자열을 Match 객체로 반환.

## 문자열 변경
- sub(): 변경된 문자열 반환
- subn(): 변경된 문자열, 변경개수 반환

### sub(바꿀문자열, 대상문자열 [, count=양수])
- 대상문자열에서 패턴과 일치하는 것을 바꿀문자열로 변경한다.
- count: 변경할 개수를 지정. 기본: 매칭되는 문자열은 다 변경
- 반환값: 변경된 문자열

### subn(바꿀문자열, 대상문자열 [, count=양수])
- sub()와 동일한 역할.
- 반환값 : (변경된 문자열, 변경된문자열개수) 를 tuple로 반환


```python
txt = "   오늘은   화요일    입니다.   ".strip() # strip()=> 좌우공백제거
print(txt)
# 여러개의 공백을 한개의 공백으로 변환
pattern = r" {2,}"   #\s -> 공백문자, tab, 엔터 

result = re.sub(pattern, " ", txt) # 함수(패턴표현식, 바꿀문자열, 대상문자열)
print(result)
```

    오늘은   화요일    입니다.
    오늘은 화요일 입니다.
    


```python
txt = """오늘은   화요일    입니다. 
내일은    수요일    입니다.
모레는    목요일    입니다.
글피는    금요일    입니다.
사흘 후는   토요일    입니다."""

# pattern = r"\s+"  # 공백, 엔터, tab을 모두 공백한개로 변환
pattern = r" {2,}"
p = re.compile(pattern)
result, cnt = p.subn(" ", txt)
print(result)
print("변경된 개수:", cnt)
```

    오늘은 화요일 입니다. 
    내일은 수요일 입니다.
    모레는 목요일 입니다.
    글피는 금요일 입니다.
    사흘 후는 토요일 입니다.
    
    변경된 개수: 10
    


```python
txt = "test1, test2, test3, test4"
# 숫자 빼고 다 제거
# p = re.compile(r"[^0-9]")
# p = re.compile(r"[^\d]")
p = re.compile(r"\D")
result = p.sub("", txt)
print(result) #"1234"
```

    1234
    

## 나누기(토큰화)
### split(대상문자열)
- pattern을 구분자로 문장을 나눈다.
- 반환: 나눈 문자열을 원소로 하는 리스트


```python
fruits = "사과,배+복숭아,수박|파인애플"
# fruits.split(",")
result = re.split(r"[,+|]", fruits)
result
```




    ['사과', '배', '복숭아', '수박', '파인애플']



# 패턴내 하위패턴 만들기 (Grouping)
- 전체 패턴에서 일부 패턴들을 묶어 하위패턴으로 만든다.
- 구문: (패턴)

## 그룹핑 예

### 전체 패턴 내에서 일부 패턴을 조회


```python
tel = "Tel:01012345689"
pattern = r"(0\d{1,2})(\d{3,4})(\d{4})"
p = re.compile(pattern)
result = p.search(tel)
if result: #조회결과가 있다면
    print(result)
    print("찾은문자열:", result.group())
    print(result.group(1), result.group(2), result.group(3))
    # 국번
#     l = result.group().split("-")
#     print('국번:', l[1])
else:
    print("조회결과 없음")
```

    <re.Match object; span=(4, 15), match='01012345689'>
    찾은문자열: 01012345689
    010 1234 5689
    


```python
##### subgroup(하위 그룹)을 이용
tel = "Tel:010-1234-5689"
pattern = r"(0\d{1,2})-(\d{3,4})-(\d{4})"
# (1번하위그룹)-(2번하위그룹)-(3번하위그룹)
p = re.compile(pattern)
result = p.search(tel)  ###  전체 패턴으로 찾는다.
if result: #조회결과가 있다면
    print(result)
    print("찾은문자열:", result.group(), result.group(0)) #group(양의정수:그룹번호)
    # 국번
    print("지역번호:", result.group(1))
    print("국번:", result.group(2))
    print("번호:", result.group(3))
else:
    print("조회결과 없음")
```

    <re.Match object; span=(4, 17), match='010-1234-5689'>
    찾은문자열: 010-1234-5689 010-1234-5689
    지역번호: 010
    국번: 1234
    번호: 5689
    


```python
emails = "abc@daum.net, test@naver.com, mymail@gmail.com"
# email 주소: 계정@도메인  => 계정과 도메인을 각각 출력
email_pattern = r"\b([\w\.-]+)@([\w\.-]+\.\w{2,4})\b"
# ()@()
p = re.compile(email_pattern)
result = p.findall(emails)  # 리스트 -> subgroup으로 찾은 문자열들만 반환.
for v in result:
    print(v, v[0], v[1])
```

    ('abc', 'daum.net') abc daum.net
    ('test', 'naver.com') test naver.com
    ('mymail', 'gmail.com') mymail gmail.com
    


```python
#  0:"(1)@(2)"
result_iter = p.finditer(emails)
for match in result_iter:
    print(f"{match.group()}, id: {match.group(1)}, domain: {match.group(2)}")
    
```

    abc@daum.net, id: abc, domain: daum.net
    test@naver.com, id: test, domain: naver.com
    mymail@gmail.com, id: mymail, domain: gmail.com
    

### 패턴 내에서 하위그룹 참조
- `\번호`
- 지정한 '번호' 번째 패턴으로 매칭된 문자열과 같은 문자열을 의미


```python
txt = """010-1111-2222
010-2222-2222
010-3333-1234
010-3456-3456"""

# 국번과 뒷자리번호가 같은 전화번호를 조회
tel_pattern = r"\d{3}-(\d{3,4})-(\1)"
# 번호-(번호:subgroup 1)-\1=>1번 subgroup으로 찾은 값과 같은 값을 가진것을 표현.
p = re.compile(tel_pattern)
for m in p.finditer(txt):
    print(m.group(), m.group(1), m.group(2))
```

    010-2222-2222 2222 2222
    010-3456-3456 3456 3456
    

### 패턴내의 특정 부분만 변경


```python
print(info)
# 주민번호 뒷 7자리중에 6자리를 감추기 -> #으로 변경.
# 주민번호를 조회한 뒤에 뒤 6자리만 변경.
jumin_pattern = r"(\d{6}-[012349])\d{6}"  # 변경안될부분을 subgroup으로 묶어준다.
p = re.compile(jumin_pattern)
result = p.sub("\g<1>######", info) # \g<1> 1번 subgroup으로 찾은 값을 그대로 사용
print(result)
```

    김정수 kjs@gmail.com 801023-0102212
    박영수 pys.abc@gmail.com 700121-1120212
    이민영 lmy-abc@naver.com 820301-2020122
    김순희 ksh@daum.net 781223-2012212
    오주연 ojy@daum.net 900522-1023218
    
    김정수 kjs@gmail.com 801023-0######
    박영수 pys.abc@gmail.com 700121-1######
    이민영 lmy-abc@naver.com 820301-2######
    김순희 ksh@daum.net 781223-2######
    오주연 ojy@daum.net 900522-1######
    
    

### group으로 묶인 것 참조(조회)
- **패턴 안에서 참조**
    - `\번호` , `r'(\d{3}) \1'` => 중복되는 것을 패턴으로 표현할 때.
- **match 조회**
    - match객체.group(번호)
- **sub() 함수에서 대체 문자로 참조**
    - `\g<번호>`


```python
# subgroup의 번호
### 하위그룹이 중첩된 경우 번호?
#### outer가 우선. 왼쪽이 우선.
tel = "010-1111-2222"
pattern = r"((\d{2,3})-((\d{3,4})-(\d{4})))"
# (1 (2)-(3 (4)-(5)))
p = re.compile(pattern)
result = p.search(tel)
print(result.group())
print("group1:", result.group(1))
print("group2:", result.group(2))
print("group3:", result.group(3))
print("group4:", result.group(4))
print("group5:", result.group(5))
```

    010-1111-2222
    group1: 010-1111-2222
    group2: 010
    group3: 1111-2222
    group4: 1111
    group5: 2222
    

# Greedy 와 Non-Greedy
- **Greedy(탐욕스러운-최대일치)** 의미
    - 주어진 패턴에 만족하는 문자열을 최대한 넓게(길게) 잡아 찾는다.
    - 매칭시 기본 방식
- **Non-Greedy(최소일치)**
    - 주어진 패턴에 만족하는 문자열을 최초의 일치하는 위치까지 찾는다
    - 개수를 나타내는 메타문자(수량자)에 **`?`**를 붙인다.
    - `*?`, `+?`, `{m,n}?`


```python
txt = "<div>파이썬 <b>정규표현식</b></div>"

# 태그만 조회: <div> <b> </b> </div>
pattern = r"<.+?>"    #r"<[\w/]+>"
p = re.compile(pattern)
result = p.findall(txt)
print(len(result), result)
```

    4 ['<div>', '<b>', '</b>', '</div>']
    

# 전방/후방 탐색
- 패턴과 일치하는 문자열을 찾을 때는 사용하되 반환(소비) 되지 않도록 하는 패턴이 있을 때 사용.
- **전방탐색**
    - 반환(소비)될 문자열들이 앞에 있는 경우.
    - 긍정 전방탐색
        - %%%(?=패턴) : %%%-반환될 패턴
    - 부정 전방탐색
        - %%%(?!패턴)  : 부정은 =를 !로 바꾼다.
- **후방탐색**
    - 반환(소비)될 문자열이 뒤에 있는 경우.
    - 긍정 후방탐색
        - (?<=패턴)%%%
    - 부정 후방탐색
        - (?<!패턴)%%%
        



```python
info = """TV 30000원 30개
컴퓨터 32000원 50개
모니터 15000원 70개"""

# info에서 가격만 조회 => 조회결과에서는 원을 빼고사용
pattern = r"\d+(?=원)"   #(? 패턴)  => subgroup의 소괄호가 아니야. 단순히 묶어주는것.
# \d+(?=원) =>찾을때: \d+원,  찾은값에서 사용할 것: \d+ . (?="패턴") 이 "패턴"으로 찾은 
                                                                    #것은 사용안함
p = re.compile(pattern)
print(p.findall(info))
for price in p.findall(info):
    print(int(price) * 0.8)
```

    ['30000', '32000', '15000']
    24000.0
    25600.0
    12000.0
    


```python
info = """TV $30000 30개
컴퓨터 $32000 50개
모니터 $15000 70개"""
# $는 메타문자 -> literal 사용할 경우  `\`를 붙인다.
pattern = r"(?<=\$)\d+"
#(?<=패턴1)패턴2 => 패턴1은 조회할때는 포함, 값을 사용할때는 제거하고 뒤의 패턴2의
#                                                                          값만 사용.
p = re.compile(pattern)
print(p.findall(info))
for price in p.findall(info):
    print(int(price) * 0.8)
```

    ['30000', '32000', '15000']
    24000.0
    25600.0
    12000.0
    
