---
layout: single
title: '함수'
typora-root-url: ../
---

# 객체지향 프로그래밍 (Object Oriented Programming)

프로그램을 구성하는 변수와 함수들에서 서로 연관성있는 것 끼리 묶어서 모듈화하는 개발하는 언어들을 객체지향프로그래밍 언어라고 한다.

# Instance(객체)
- 연관성 있는 값들과 그 값들을 처리하는 함수(메소드)들을 묶어서 가지고 있는 것(값).
- 객체의 구성요소
    - 속성(Attribute)
        - 객체의 데이터/상태로 객체를 구성하는 값들.
    - 메소드(method)
        - 객체가 제공하는 기능으로 주로 Attribute들을 처리한다.
        

## Class(클래스) 정의

- class란: 객체의 설계도
    - 동일한 형태의 객체들이 가져야 하는 Attribute와 Method들을 정의 한 것
        - 클래스를 정의할 때 어떤 속성과 메소드를 가지는지 먼저 설계해야 한다.
    - 클래스로 부터 객체(instance)를 생성한 뒤 사용한다.
```python
class 클래스이름:  #선언부
    #클래스 구현
    #메소드들을 정의
```
- 클래스 이름의 관례: 파스칼 표기법-각 단어의 첫글자는 대문자 나머진 소문자로 정의한다.
    - ex) Person, Student, HighSchoolStudent
    

## 클래스로부터 객체(Instance) 생성
- 클래스는 데이터 타입 instance는 값이다.

```python
변수 = 클래스이름()
```


```python
# 아무것도 없는 클래스 생성
class Person:
    pass
# 인스턴스( Instance ) : 값, Class : Data Type
p = Person() # Instance 생성
```


```python
print(type(p))    
```

    <class '__main__.Person'>
    

## Attribute(속성) 
- attribute는 객체의 데이터, 객체가 가지는 값, 객체의 상태

### 객체에 속성을 추가, 조회
- 객체의 속성 추가(값 변경)
    1. Initializer(생성자)를 통한 추가 ( 보통 )
    2. 객체.속성명 = 값 (추가/변경) 
    3. 메소드를 통한 추가/변경 ( 추천 -> 정보 은닉 ) 
    - 1번 방식 (Initializer)은 초기화할 때. 2, 3은 속성값을 변경할 때 적용.
- 속성 값 조회
    - 객체.속성명
- **객체.\_\_dict\_\_**
    - 객체가 가지고 있는 Attribute들을 dictionary로 반환한다.


```python
# 2. 객체에 송석을 추가, 조회 : 객체.속성명 = 값 ( 추가 / 값 )
p = Person() # 객체 생성 및 변수에 할당
```


```python
print(p.__dict__) # 객체가 가지는 속성들을 조회
```

    {}
    


```python
# 속성값들을 추가
p.name = "홍길동"
p.age = 30
p.address = "인천"
p.tall = 174.5
```


```python
print(p.__dict__) # P 의 정보를 나타냄
```

    {'name': '홍길동', 'age': 30, 'address': '인천', 'tall': 174.5}
    


```python
# 속성값들을 조회, 추가
print( p.name+'유재석', p.age+20, p.address+'서울', p.tall+20.2 )
```

    홍길동유재석 50 인천서울 194.7
    


```python
print(f'{p.name}은 {p.age}세이고 {p.address}에 살고있습니다.')
```

    홍길동은 30세이고 인천에 살고있습니다.
    


```python
p2 = Person() # Person instance를 생성해서 p2에 대입
```


```python
print(p2.__dict__)
```

    {}
    


```python
p2.name = '정준하'
p2.age = 20
p2.address = '부산'
p2.email = 'a@a.com'
```


```python
print(p2.__dict__)
```

    {'name': '정준하', 'age': 20, 'address': '부산', 'email': 'a@a.com'}
    


```python
print( p2.name, p2.age, p2.address, p2.email )
```

    정준하 20 부산 a@a.com
    


```python
print( f'{p2.name}이고 {p2.age}세 {p2.address}에살고있습니다.' )
```

    정준하이고 20세 부산에살고있습니다.
    

### 생성자(Initializer)
- 객체를 생성할 때 호출되는 특수메소드로 attribute들 초기화에 하는 코드를 구현한다.
    - Inializer를 이용해 초기화하는 Attribute들이 그 클래스의 객체들이 가져야 하는 공통 Attribute가 된다.
- 구문
```python
def __init__(self [,매개변수들 선언]):  #[ ] 옵션.
    # 구현 -> attribute(instance변수) 초기화
    self.속성명 = 값
```
> 변수 초기화: 처음 변수 만들어서 처음 값 대입.    

### self  parameter
- 메소드는 반드시 한개 이상의 parameter를 선언해야 하고 그 첫번째 parameter를 말한다.
- 메소드 호출시 그 메소드를 소유한 instance가 self parameter에 할당된다.
- Initializer의 self
    - 현재 만들어 지고 있는 객체를 받는다.
- 메소드의 self
    - 메소드를 소유한 객체를 받는다.
- Caller에서 생성자/메소드에 전달된 argument들을 받을 parameter는 두번째 변수부터 선언한다.    



```python
# initializer를 이용해서 attribute(객체 변수)를 초기화
class Person:
# initializer 클래스 안에 정의 , self를 정의
    def __init__(self, name, age, address=None):   # *args, **kwargs
#                        ㄴ Parameter
        """
        Parameter로 name, age, address를 받아서 ( 객체가 생성되는 시점 )
        그 값들을 attribute로 저장.       
        """
        # 메소드에서 attribute 조회. self.변수명 = 값 ( 대입 ), self. 변수명 ( 조회 )
        self.name = name
        self.age = age # self.age -> age 속성, age : parameter 변수
        self.address = address 
        self.email = None
    
```


```python
# 객체 생성 : Class 이름( 변수1 대입할 값 ( name ), 변수2 대입할 값 ( age ) ) ==>  __init__( self, 변수1, 변수2 ) 호출
# p = Person() TypeError: Person.__init__() missing 2 required positional arguments: 'name' and 'age'
                              # Person 클래스 안에 Argument : name , age 안불음 
```


```python
p = Person('홍길동', 24, '서울') # '홍' -> name, 33 -> age, '서울' -> address
```


```python
print(p.__dict__)
```

    {'name': '홍길동', 'age': 24, 'address': '서울', 'email': None}
    


```python
p.tall = 174 # 가능함. 좋은 방식은 아니다. attribute 초기화는 init을 이용해서 한다.
             # 객체 생성 후 ' 객체.변수 = 값 '은 기존 attribute의 값을 변경할 때 한다.
```


```python
print(p.__dict__)
```

    {'name': '홍길동', 'age': 24, 'address': '서울', 'email': None, 'tall': 174}
    


```python
# self => Person 메모리 공간 이름
# 1. class Person 이라는 메모리 공간을 잡아줌
# 2. __init__() 메소드 호출 
# 3. 생성된 객체를 반환( 리턴 ) p2 = self
```

### Instance 메소드(method)
- 객체가 제공하는 기능
- 객체의 attribute 값을 처리하는 기능을 구현한다.
- 구문
```python
def 이름(self [, 매개변수들 선언]):
    # 구현
    # attribute 사용(조회/대입)
    self.attribute 
```
- self (첫번째 매개변수)
    - 메소드를 소유한 객체를 받는 변수
    - 호출할 때 전달하는 argument를 받는 매개변수는 두번째 부터 선언한다.
![self](images/ch06_01.png)
    
- **메소드 호출**
    - `객체.메소드이름([argument, ...])`


```python
class Person:
    
    def __init__(self, name, age, address=None ):
        self.name = name
        self.age = age
        self.address = address
        self.email = None

# 메소드 
    def print_info(self): # argument를 안받는 메소드
        # person의 attribute 값들을 출력
        print(f'이름: {self.name}, 나이: {self.age}, 주소:{self.address}, 이메일: {self.email}')
    
    def add_age(self, age): # argument가 한개인 메소드
        # 나이를 받아서 attribute age에 더한다.
#         self = self.age + age 밑에 있는 것과 동일
        self.age += age
# 클래스 생성 완료
```


```python
# Person 클래스를 가지고 객체를 만듬, 
p1 = Person('홍길동', 24, '서울')
```


```python
p1.print_info()
```

    이름: 홍길동, 나이: 24, 주소:서울, 이메일: None
    


```python
p1.email = 'a@a.com' # 이메일 값에 a@a.com 값을 대입 
```


```python
p1.print_info()
```

    이름: 홍길동, 나이: 24, 주소:서울, 이메일: a@a.com
    


```python
p1.add_age(3) # 현재 나이 : 24에 3을 더한다.
```


```python
p1.print_info()
```

    이름: 홍길동, 나이: 27, 주소:서울, 이메일: a@a.com
    


```python
class Person1:
    def __init__(self, name, age, address,email=None):
        self.name = name
        self.age = age
        self.address = address
        self.email = email
    def print_info(self):
        print(f'이름:{self.name}, 나이:{self.age}, 주소:{self.address},이메일:{self.email}')
    def add_age(self,age):
        self.age += age
```


```python
p2 = Person('홍길동',20,'서울')
```


```python
p2.email = 'g@g.com'
```


```python
p2.add_age(2)
```


```python
p2.print_info()
```

    이름: 홍길동, 나이: 22, 주소:서울, 이메일: g@g.com
    


```python
class Ps:
    def __init__(self,name,age,address,email=None):
        self.name=name
        self.age=age
        self.address=address
        self.email=email
    def print_info(self):
        print(f'이름:{self.name},나이:{self.age},주소:{self.address},이메일:{self.email}')
    def age_add(self,age):
        self.age=age
```


```python
p3 = Ps('홍길동',25,'서울')
```


```python
print(p3.__dict__)
```

    {'name': '홍길동', 'age': 25, 'address': '서울', 'email': None}
    


```python
p3.email = 'p@p.com'
```


```python
p3.print_info()
```

    이름:홍길동,나이:25,주소:서울,이메일:p@p.com
    


```python
class String:
    def __init__(self, value):
        self.value = value
    def split(self):
        print(f'{self.value}를 분리합니다')
    def upper(self):
        print(f'{self.value}를 대문자로 변경합니다')
        return self.value.upper()
```


```python
s = String('a b c')
```


```python
s.split()
```

    a b c를 분리합니다
    


```python
v = s.upper()
```

    a b c를 대문자로 변경합니다
    


```python
v
```




    'A B C'



## 정보 은닉 (Information Hiding)
- Attribute의 값을 caller(객체 외부)가 마음대로 바꾸지 못하게 하기 위해 직접 호출을 막고 setter/getter 메소드를 통해 값을 변경/조회 하도록 한다.
    - 데이터 보호가 주목적이다.
    - 변경 메소드에 Attribube 변경 조건을 넣어 업무 규칙에 맞는 값들만 변경되도록 처리한다.
    - **setter**
        - Attribute의 값을 변경하는 메소드. 관례상 set 으로 시작
    - **getter**
        - Attribute의 값을 조회하는 메소드. 관례상 get 으로 시작
- Attribute 직접 호출 막기
    - Attribute의 이름을 \_\_(double underscore)로 시작한다. (\_\_로 끝나면 안된다.)
    - 같은 클래스에서는 선언한 이름으로 사용가능하지만 외부에서는 그 이름으로 호출할 수 없게 된다.
    


```python
## Person class에 정보 은닉 적용
### 1, attribute 변수들을 외부에서 호출 할수 없도록 만들어 준다.
###              - self.__변수명 = 초기값 (  __ 으로 끝나면 안됨 )
### 2. attribute 변수들을 조회(getter), 변경(setter)하는 메소드를 정의한다.
```


```python
class Person():
    def __init__(self, name, age, address):
        self.name = name
        self.__age = age # 함부로 변경하지 못하게 함
        self.address = address
        self.email = None
        
# age 값을 조회하는 메소드
    def get_age(self):
        return self.__age # 같은 class 에서는 __age로 호출 가능.
# age 값을 변경하는 메소드
    def set_age(self, age):
        if 0 <= age <= 100:
            self.__age = age
        else:
            print(f'{age}는 나이에 넣을 수 없는다. 0 ~ 100 사이 정수를 넣어주세요')   
```


```python
p = Person('홍길동',20,'서울')
```


```python
print(p.name, p.address, p.email)
```

    홍길동 서울 None
    


```python
print(p.__dict__)
```

    {'name': '홍길동', '_Person__age': 20, 'address': '서울', 'email': None}
    


```python
print(p._Person__age)
# p._Person__age = 3 # 완벽하게 막지 못함
```

    20
    


```python
print(p.__dict__)
```

    {'name': '홍길동', '_Person__age': 20, 'address': '서울', 'email': None}
    


```python
print(p.get_age())
```

    20
    


```python
p.set_age(250)
```

    250는 나이에 넣을 수 없는다. 0 ~ 100 사이 정수를 넣어주세요
    


```python
print(p.__dict__)
# p.set_age('스무살')
```

    {'name': '홍길동', '_Person__age': 20, 'address': '서울', 'email': None}
    

### property함수를 사용
- 은닉된 instance 변수의 값을 사용할 때 getter/setter대신 변수를 사용하는 방식으로 호출할 수 있도록 한다.
- 구현
    1. getter/setter 메소드를 만든다.
    2. 변수 = property(getter, setter) 를 등록한다.
    3. 호출
        - 값조회: 변수를 사용 => getter가 호출 된다.
        - 값변경: 변수 = 변경할 값 => setter가 호출 된다.


```python
class Person2:
    def __init__(self, name, age, address):
        self.__name = name
        self.__age = age 
        self.address = address
        self.email = None
        
    def print_info(self):
        print(f'이름:{self.name},나이:{self.age},주소:{self.address},이메일:{self.email}')
        
    def get_age(self):
        return self.__age 
    def set_age(self, age):
        if 0 <= age <= 100:
            self.__age = age
        else:
            print(f'{age}는 나이에 넣을 수 없는다. 0 ~ 100 사이 정수를 넣어주세요')
            
    def get_name(self):
        return self.__name
    def set_name(self, name):
        if len(name) >= 2:
            self.__name = name
        else:
            print('이름은 두글자 이상만 가능합니다.')
            
    name = property(get_name, set_name)
    age = property(get_age, set_age)
```


```python
p2 = Person2('홍길동',40,'서울')
# name, age 사용 -> 메소드
p2.set_name('유재석')
p2.set_age(20)
```


```python
print(p2.print_info())
```

    이름:유재석,나이:20,주소:서울,이메일:None
    None
    


```python
print(p2.get_age())
```

    20
    


```python
print(p2.__dict__)
```

    {'_Person2__name': '유재석', '_Person2__age': 20, 'address': '서울', 'email': None}
    


```python
# address, email 사용 -> 변수를 호출
print(p2.address)
```

    서울
    


```python
p3 = Person2('유재석',40,'인천')
p3.address = '새주소'
p3.email = '새 이메일주소'
p3.name = '새이름'
p3.age = 20
```


```python
print(p3.name,p3.age,p3.email)
```

    새이름 20 새 이메일주소
    


```python
p3.name = '강'
p3.age = 50000
p2.name = 'g'
```

    이름은 두글자 이상만 가능합니다.
    50000는 나이에 넣을 수 없는다. 0 ~ 100 사이 정수를 넣어주세요
    이름은 두글자 이상만 가능합니다.
    


```python
print(p3.__dict__)
```

    {'_Person2__name': '새이름', '_Person2__age': 20, 'address': '새주소', 'email': '새 이메일주소'}
    


```python
p3.print_info()
```

    이름:새이름,나이:20,주소:새주소,이메일:새 이메일주소
    

### 데코레이터(decorator)를 이용해 property 지정.
- setter/getter 구현 + property()를 이용해 변수 등록 하는 것을 더 간단하게 구현하는 방식
- setter/getter 메소드이름을 변수처럼 지정. (보통은 같은 이름으로 지정)
- getter메소드: @property 데코레이터를 선언  
- setter메소드: @getter메소드이름.setter  데코레이터를 선언.
    - 반드시 getter 메소드를 먼저 정의한다.
    - setter메소드 이름은 getter와 동일해야 한다.
- getter/setter의 이름을 Attribute 변수처럼 사용한다.
- 주의: getter/setter 메소드를 직접 호출 할 수 없다. 변수형식으로만 호출가능하다.


```python
class Person3:
    def __init__(self, name, age, address):
        self.__name = name
        self.__age = age
        self.address = address
        self.email = None
    
    @property
    def age(self):
        return self.__age 
    
    @age.setter
    def age(self, age):
        if 0 <= age <= 100:
            self.__age = age
        else:
            print(f'{age}는 나이에 넣을 수 없는다. 0 ~ 100 사이 정수를 넣어주세요')
    
    @property
    def name(self):
        return self.__name
    
    @name.setter
    def name(self, name):
        if len(name) >= 2:
            self.__name = name
        else:
            print('이름은 두글자 이상만 가능합니다.')
```


```python
p4 = Person3('박명수',30,'서울')
```


```python
print(p4.name, p4.age, p4.address, p4.email)
```

    박명수 30 서울 None
    


```python
print(p4.__dict__) # Person3 함수 => p4에 대입
```

    {'_Person3__name': '박명수', '_Person3__age': 30, 'address': '서울', 'email': None}
    


```python
p4.name = '홍길동'
p4.address = '인천'
p4.email = 'a@a.com'
```


```python
p4.age = 260
```

    260는 나이에 넣을 수 없는다. 0 ~ 100 사이 정수를 넣어주세요
    


```python
print(p4.name, p4.age, p4.address, p4.email) # age 0 ~ 100 사이 정수 X => 출력안됨
```

    홍길동 30 인천 a@a.com
    

## 연습문제

- 제품 클래스 구현
- 속성 : 제품ID:str 제품이름: str, 제품가격:int, 제조사이름:str
-       정보은닉에 맞춰서 작성. 값을 대입/조회 하는 것은 변수처리 방식을 할 수 있도록 구현.
- 메소드: 전체 정보를 출력하는 메소드

메소드 : setter-4개, getter-4개. 전체정보 출력하는 메소드-1개


```python
# property() 를 이용
class Test:
    def __init__(self, item_id, item_name, price, make):
        self.__item_id = item_id
        self.__item_name = item_name
        self.__price = price
        self.__make = make
    def get_item_id(self):
        return self.__item_id
    def set_item_id(self,new_item_id):
        print('set_item_id()')
        if new_item_id:
            self.__item_id = new_item_id
    def get_item_name(self):
        return self.__item_name
    def set_item_name(self, new_item_name):
        print('set_item_name()')
        if new_item_name:
            self.__item_name = new_item_name
    def get_price(self):
        print('get_price()')
        return self.__price
    def set_price(self,new_price):
        print('set_price()')
        if new_price > 0:
            self.__price = new_price
    def get_make(self):
        return self.__make
    def set_make(self,new_make):
        if new_make and len(new_make) >= 2:
            self.__make = new_make
    def print_info(self):
        value = f"제품:{self.__item_id}, 제품명:{self.__item_name}, 가격:{self.__price}, 제조사:{self.__make}"
        print(value)
    item_id = property(get_item_id, set_item_id)
    item_name = property(get_item_name, set_item_name)
    price = property(get_price, set_price)
    make = property(get_make, set_make)
```


```python
i = Test('노트북','삼성노트북', 200000, '삼성')
```


```python
i.print_info()
```

    제품:노트북, 제품명:삼성노트북, 가격:200000, 제조사:삼성
    


```python
i.item_id=None
```

    set_item_id()
    


```python
print(i.item_id)
```

    노트북
    


```python
i.item_name='LG노트북'
```

    set_item_name()
    


```python
print(i.item_name)
```

    LG노트북
    


```python
i.price= -123
```

    set_price()
    


```python
print(i.price) # price 값에 음수 X -> 원래 있던 price 값 출력
```

    get_price()
    200000
    


```python
i.price = 10000
```

    set_price()
    


```python
i.make='a'
```


```python
print(i.make) # make 값 두글자 이상 X -> 원래 있었던 make 값 출력
```

    삼성
    


```python
i.make='LG'
```


```python
print(i.make)
```

    LG
    


```python
print(i.item_id, i.item_name, i.price, i.make)
```

    get_price()
    노트북 LG노트북 10000 LG
    

## 상속 (Inheritance)

- 기존 클래스를 확장하여 새로운 클래스를 구현한다.
    - 생성된 객체(instance)가 기존 클래스에 정의된 Attribute나 method를 사용할 수있고 그 외의 추가적인 member들을 가질 수 있는 클래스를 구현하는 방법.
- **기반(Base) 클래스, 상위(Super) 클래스, 부모(Parent) 클래스**
    - 물려 주는 클래스.
    - 상속하는 클래스에 비해 더 추상적인 클래스가 된다. 
    - 상속하는 클래스의 데이터 타입이 된다.
- **파생(Derived) 클래스, 하위(Sub) 클래스, 자식(Child) 클래스**
    - 상속하는 클래스.
    - 상속을 해준 클래스 보다 좀더 구체적인 클래스가 된다.
- 상위 클래스와 하위 클래스는 계층관계를 이룬다.
    - 상위 클래스는 하위 클래스 객체의 타입이 된다.


```python
class Person:
    def go(self):
        print('간다')
    def eat(self):
        print('먹다')
# Person 을 상속해서 Student를 정의
## Class 클래스이름( 상속할 클래스이름 [ , 상속할클래스이름2, .. ] )
### 설계도를 그릴때는 Person <- Student 화살표 그림
class Student(Person):
    def study(self):
        print('학생은공부')

class Teacher(Person):
    def teach(self):
        print('수업을가르치다')
```


```python
# 객체 생성
## 부모클래스 : Person 클래스 안에 정의를 자식 클래스 : Student, Teacher 에서도 사용가능
# t.study() Error : Teacher -> study X , Teacher, Student 서로 독립적인 객체 
```


```python
s = Student()
```


```python
s.study()
s.eat()
s.go()
```

    학생은공부
    먹다
    간다
    


```python
t = Teacher()
t.teach()
t.eat()
t.go()
```

    수업을가르치다
    먹다
    간다
    

### 다중상속과 단일 상속
- 다중상속
    - 여러 클래스로부터 상속할 수 있다
- 단일상속
    - 하나의 클래스로 부터만 상속할 수 있다.
- 파이썬은 다중상속을 지원한다.
- MRO (Method Resolution Order)
    - 다중상속시 메소드 호출할 때 그 메소드를 찾는 순서. 
    1. 자기자신
    2. 상위클래스(하위에서 상위로 올라간다)
        - 다중상속의 경우 먼저 선언한 클래스 부터 찾는다. (왼쪽->오른쪽)
- MRO 순서 조회 
    - Class이름.mro()


```python
# 왼쪽 -> 오른쪽 찾기, 최상위 클래스 전체 : Object
class D:
    pass
class E:
    pass
class F:
    pass
class B(D,E):
    pass
class C(F):
    pass
class A(B,C):
    pass
```


```python
A.mro()
```




    [__main__.A,
     __main__.B,
     __main__.D,
     __main__.E,
     __main__.C,
     __main__.F,
     object]



### Method Overriding (메소드 재정의)
상위 클래스의 메소드의 구현부를 하위 클래스에서 다시 구현하는 것을 말한다.  
상위 클래스는 모든 하위 클래스들에 적용할 수 있는 추상적인 구현밖에는 못한다.  
이 경우 하위 클래스에서 그 내용을 자신에 맞게 좀더 구체적으로 재구현할 수 있게 해주는 것을 Method Overriding이라고 한다.  
방법은 하위 클래스에서 overriding할 메소드의 선언문은 그래로 사용하고 그 구현부는 재구현하면 된다.  

### super() 내장함수
- 하위 클래스에서 상위 클래스의 instance를 반환(return) 해주는 함수
- 구문
```python
super().메소드명() 
```
- 상위 클래스의 Instance 메소드를 호출할 때 – super().메소드()
    - 특히 method overriding을 한 클래스에서 상위 클래스의 overriding한 메소드를 호출 할 경우 반드시 `super().메소드() `형식으로 호출해야 한다.
- 같은 클래스의 Instance 메소드를 호출할 때 – self.메소드()


```python
# 메소드에서 self.xxx : 같은 클래스에 정의된 메소드나 attribute( instance 변수 ) 호출
## super().xxx : 부모클래스에 정의된 메소드나 attribute( 부모객체의 attribute ) 호출
```


```python
class Person2:
    def go(self):
        self.eat()
        print('가다')
#       print('스쿨버스를 타고 간다.') => Student 방식
    def eat(self):
        print('먹는다. - Person2')
#       print('급식을 먹는다.') => Student 방식        
class Student2(Person2):
    # go() 메소드를 Student 클래스에 맞게 좀더 구체화된 내용으로 재정의( overriding ) 한다.
    # 상위클래스에 정의된 메소드와 동일한 선언(이름)으로 메소드를 구현.
    ## 부모클래스와 같은 일을 함, 같은 속성의 메소드 -> 동일한 이름 메소드 구현
    def go(self):
        print('스쿨버스 타고 등교한다.')
    def eat(self):
        print('학교식당에간다')
        print('급식을 받는다')
        #print('먹는다') # Super Class에 정의한 eat()을 실행시킨다.
        super().eat() # super() : 부모클래스를 가르킨다.
    def study(self):
        print('학생이 공부한다.,2')
class Teacher2(Person2):
    def teach(self):
        print('교사가 공부한다,2')
```


```python
t = Teacher2()
t.teach()
t.go()
t.eat()
```

    교사가 공부한다,2
    먹는다. - Person2
    가다
    먹는다. - Person2
    


```python
s = Student2()
s.study()
s.go()
```

    학생이 공부한다.,2
    스쿨버스 타고 등교한다.
    


```python
s.eat()
```

    학교식당에간다
    급식을 받는다
    먹는다. - Person2
    


```python
Teacher2.mro()
```




    [__main__.Teacher2, __main__.Person2, object]




```python
# 상속과 Attribute
class Person3:
    
    def __init__( self, name, age, address=None ):
        self.__name = name
        self.__age = age
        self.__address = address
        
    @property
    def name(self):
        return self.__name
    @name.setter
    def name(self, name):
        if name:
            self.__name = name
        else:
            print('이름을 변경 못함')
    
    @property
    def age(self):
        return self.__age
    @age.setter
    def age(self, age):
        if 8 <= age <= 19:
            self.__age = age
        else:
            print('나이을 변경 못함')

    @property
    def address(self):
        return self.__address
    @address.setter
    def address(self, address):
        if address:
            self.__address = address
        else:
            print('주소을 변경 못함')

    # 나이를 더하는 메소드
    def add_age( self, age ):
        self.age = self.age + age
#         @age.setter : age = @property: age + 파라미터 age
    # Person 객체의 속성값들을 하나의 문자열로 묶어서 반환.
    def get_info( self ): # getter 메소드 호출.
        return f'이름:{self.name}, 나이:{self.age},주소:{self.address}'

```


```python
# Student의 속성 : name , age, address => 공통 속성, grade ( 성적 - 학생의 속성 )
class Student3( Person3 ):
    def __init__(self, name, age, address, grade ):
        # name, age, address => 부모클래스인 Person의 속성
        super().__init__(name, age, address)  
        self.__grade = grade
        
    @property
    def grade(self):
        return self.__grade
    @grade.setter
    def grade(self, grade):
        if grade > 0:
            self.__grade = grade
        else:
            print('grade 변경못함')
            
    # method overridinf => Person3에 정의된 get_info()에 grade까지 return 하도록 재정의
    def get_info( self ):
        i = super().get_info() # 이름, 나이, 주소는 Person3( 부모클래스 )에 정의된 메소드 호춯.
        return f'{i}, 성적:{self.grade}' # getter : grade 호출
    
```


```python
# Student의 속성 : name , age, address => 공통 속성, subject (과목 - Teacher의 속성), 
# job : 직책=> 특별한 대입조건이 없음
# 상속 : 속성 - name, age, address
# 메소드 - add_age(), get_info()메소드
class Teacher3(Person3):
    
    def __init__(self, name, age, address, subject, job=None ): # job : 직책
        # name, age, address => 부모클래스의 __init__을 이용해서 초기화.
        super().__init__( name, age, address )
        self.__subject = subject
        self.job = job # setter가 필요없는 변수
    @property
    def subject(self):
        return self.__subject
    @subject.setter
    def subject(self, subject):
        if subject: # if subject : None 면 else 출력
            self.__subject = subject
        else:
            print('과목을 수정못함')
            
    # Teacher 객체의 attribute들을 반환 => get_info()를 method overriding
    def get_info(self):
        # 이름, 나이, 주소 -> Person3의 get_info()를 사용.
        i = super().get_info()
        return f"{i}, 담당과목:{self.subject}, 담당직책:{ self.job if self.job else '없음' }"
        
```


```python
t = Teacher3('이선생', 30, '부산', '수학', '학생주임')
info = t.get_info()
print( info )
```

    이름:이선생, 나이:30,주소:부산, 담당과목:수학, 담당직책:학생주임
    


```python
t.subject = None
```

    과목을 수정못함
    


```python
t.job = None
info = t.get_info() # job : 직책=> 특별한 대입조건이 없음 ->> None 값 
```


```python
print(info)
```

    이름:이선생, 나이:30,주소:부산, 담당과목:수학, 담당직책:없음
    


```python
s = Student3( '홍길동', 24, '서울', 3 ) 
print(s.name, s.age, s.address, s.grade) 
```

    홍길동 24 서울 3
    


```python
s.add_age(-3) # getter
```

    나이을 변경 못함
    


```python
print(s.age)
```

    24
    


```python
info = s.get_info() # s : Student
print( info )
```

    이름:홍길동, 나이:24,주소:서울, 성적:3
    


```python
s.age = 120 # getter
```

    나이을 변경 못함
    


```python
print(s.get_info())
```

    이름:홍길동, 나이:24,주소:서울, 성적:3
    


```python
s.name = None
s.grade = -34
```

    이름을 변경 못함
    grade 변경못함
    

## 객체 관련 유용한 내장 함수, 특수 변수
-  **`isinstance(객체, 클래스이름-datatype)`** : bool
    - 객체가 두번째 매개변수로 지정한 클래스의 타입이면 True, 아니면 False 반환
    - 여러개의 타입여부를 확인할 경우 class이름(type)들을 **튜플(tuple)로** 묶어 준다.
    - 상위 클래스는 하위 클래스객체의 타입이 되므로 객체와 그 객체의 상위 클래스 비교시 True가 나온다.
- **`객체.__dict__`**
     - 객체가 가지고 있는 Attribute 변수들과 대입된 값을 dictionary에 넣어 반환
- **`객체.__class__`**
    - 객체의 타입을 반환


```python
p = Person3('이름', 20, '주소')
t = Teacher3( '이선생', 30, '부산', '영어', '교감')
s = Student3( '홍길동', 15, '서울', 1)
```


```python
# 값(객체) 의 타입 = 생성한 class, 생성한 class의 상위 class들
## t의 타입 : Teacger3, Person3, Object
# 코드를 최소화 할수 있고 변경 추가 수정을 할수있다
def test(person):
    person.add_age(3)
```


```python
# 값(객체) 의 타입 = 생성한 class, 생성한 class의 상위 class들
## t의 타입 : Teacger3, Person3, Object
# 코드를 최소화 할수 있고 변경 추가 수정을 할수있다
def test(person):
    person.add_age(3)
    print(person.get_info())
```


```python
test(p) # => Person add_age, Perosn get_info
```

    나이을 변경 못함
    이름:이름, 나이:20,주소:주소
    


```python
test(t) # => Person add_age, Teacher get_info
```

    나이을 변경 못함
    이름:이선생, 나이:30,주소:부산, 담당과목:영어, 담당직책:교감
    


```python
test(s) # => Person add_age, Student get_info
```

    이름:홍길동, 나이:18,주소:서울, 성적:1
    


```python
# 변수 p의 타입이 xxx 클래스인가?
# type(p) == Person3
print(isinstance(p, Person3))
print(isinstance(t, Teacher3), isinstance(s, Student3))
```

    True
    True True
    


```python
# 상위클래스가 자식클래스 객체의 타입이 된다
print(isinstance(t, Person3), isinstance(s, Person3))
print(isinstance( p, Person3 ), isinstance( p, Person), isinstance( p, str ))
```

    True True
    True False False
    


```python
s = 30
print(isinstance( s, ( int, float )))
```

    True
    


```python
def function(value):
    if isinstance( value, (int, float)):
        print(value ** 2)
    else:
        print('계산 못하는 타입', type(value))
```


```python
function(10)
```

    100
    


```python
function(2.5)
```

    6.25
    


```python
function('10')
```

    계산 못하는 타입 <class 'str'>
    


```python
def func(value):
    # Student, Teacher 객체를 받아서 add_age() 이용해서 나이를 변경하고 attribute들을 출력
    if isinstance(value, Person3): # Person3, Person3의 모든 하위 객체 ==> True
        value.add_age(1) # 실행할때마다 + 1 => 19살이 넘어가면 Person3 if 8 <= age <= 19: 
        i = value.get_info()
        print(i)
```


```python
func(s)
```


```python
func('abc')
func(t)
```

    나이을 변경 못함
    이름:이선생, 나이:30,주소:부산, 담당과목:영어, 담당직책:교감
    


```python
print(p.__dict__)
```

    {'_Person3__name': '이름', '_Person3__age': 20, '_Person3__address': '주소'}
    


```python
print(t.__dict__)
```

    {'_Person3__name': '이선생', '_Person3__age': 30, '_Person3__address': '부산', '_Teacher3__subject': '영어', 'job': '교감'}
    


```python
print(type(t.__class__))
```

    <class 'type'>
    


```python
# 로그를 남길때
print(t.__class__.__name__) # class 이름을 문자열로 반환.
print(s.__class__.__name__)
```

    Teacher3
    int
    


```python
# 특수 메소드
class Person:
    # 파이썬 실행환경 호춯 메소드 : __init__ , # 파이썬 실행 환경이 __init__을 불러줌 ( Run time )
    ## 언제 : 객체 생성할때 __init__ 실행됨
    ### Initializer : 값을 초기화 함, 특수메소드    
    def __init__(self):
        print('Perosn 객체가 생성됨')
```


```python
p = Person()
```

    Perosn 객체가 생성됨
    


```python
# 특수 메소드 ( 스페셜 메소드 ) : call bakc
    # 메소드 -> 어느시점에 호출되는지 
```

## 특수 메소드


### 특수 메소드란
- 특정한 상황에서 사용될 때 자동으로 호출되도록 파이썬 실행환경에 정의된 약속된 메소드들이다. 객체에 특정 기능들을 추가할 때 사용한다.
    - 정의한 메소드와 그것을 호출하는 함수가 다르다.
         - ex) `__init__()` => 객체 생성할 때 호출 된다.
- 메소드 명이 더블 언더스코어로 시작하고 끝난다. 
    - ex) `__init__(), __str__()`
- 매직 메소드(Magic Method), 던더(DUNDER) 메소드라고도 한다.
- 특수메소드 종류
    - https://docs.python.org/ko/3/reference/datamodel.html#special-method-names

### 주요 특수메소드
- **`__init__(self [, …])`**
    - Initializer
    - 객체 생성시 호출 된다.
    - 객체 생성시 Attribute의 값들을 초기화하는 것을 구현한다.
    - self 변수로 받은 instance에 Attribute를 설정한다.
- **`__call__(self [, …])`**
- 객체를 함수처럼 호출 하면 실행되는 메소드
    - Argument를 받을 Parameter 변수는 self 변수 다음에 필요한대로 선언한다.
    - 처리결과를 반환하도록 구현할 경우 `return value` 구문을 넣는다. (필수는 아니다.)




```python
class Plus:
    def __init__( self, num1, num2 ):
        self.num1 = num1
        self.num2 = num2
    
#     def calculate(self):
#         return self.num1 + self.num2
    def __call__(self):
        # 객체를 함수처름 호출할 떄 호출될 메소드
        ## 객체가 하나의 메소드를 제공하고나 메인 메소드( 기능 )가 하나 있을 때 정의한다
        return self.num1 + self.num2
    
```


```python
plus = Plus(21, 24) # num1, num2 == 10, 20 을 객체에 넣음
# p.calculate() => 대신 plus()로 한번에 호출가능 
plus() # 객체() -> 객체를 함수처럼 호출( 실행 ) ===> __call__() 가 호출됨
```




    45




```python
class Square:
    def __init__( self, num):
        self.num = num
    
    # n 제곱하는 메소드
    
    def calculate(self, n):
        return self.num ** n
    
    def __call__(self, n): # 파라미터는 1개 이상 원하는 대로 정의
        return self.num ** n
```


```python
square = Square(5)
```


```python
print(square.calculate(2)) # 5의 2제곱
print(square(3)) # 5의 3제곱
```

    25
    125
    

- **`__repr__(self)`**
    - Instance(객체) 자체를 표현할 수 있는 문자열을 반환한다.
        - 보통 객체 생성하는 구문을 문자열로 반환한다.
        - 반환된 문자열을 eval() 에 넣으면 동일한 attribute값들을 가진 객체를 생성할 수 있도록 정의한다.
    - 내장함수 **repr(객체)** 호출할 때 이 메소드가 호출 된다.
    - 대화형 IDE(REPL) 에서 객체를 참조하는 변수 출력할 때도 호출된다.
> - eval(문자열)
>     - 실행 가능한 구문의 문자열을 받아서 실행한다.

- **`__str__(self)`**
    - Instance(객체)의 Attribute들을 묶어서 문자열로 반환한다.
    - 내장 함수 **str(객체)**  호출할 때 이 메소드가 호출 된다.
        - str() 호출할 때 객체에 `__str__()`의 정의 안되 있으면 `__repr__()` 을 호출한다. `__repr__()`도 없으면 상위클래스에 정의된 `__str__()`을 호출한다.
        - print() 함수는 값을 문자열로 변환해서 출력한다. 이때 그 값을 str() 에 넣어 문자열로 변환한다.


```python
class Person:
    def __init__(self,name,age,address):
        self.name = name
        self.age = age
        self.address = address
    def __repr__(self): # 
        return f"Person('{self.name}',{self.age},'{self.address}')"
    def __str__(self): # 많이 함 어떤 인스턴스 문자열로 구성되는지
        return f"이름:{self.name}\n나이:{self.age}\n주소:{self.address}"
```


```python
p = Person('홍길동',23,'서울')
v = repr(p) # p.__repr__() 호출한 결과(str)를 반환 => p 값을 만드는(생성하는) 구문을 반환.
```


```python
print(v)
```

    Person('홍길동',23,'서울')
    


```python
v2 = str(p) # str(p) -> 값.__str__()의 반환값을 반환해준다.
print(v2)
```

    이름:홍길동
    나이:23
    주소:서울
    


```python
print(eval('1 + 1'))
```

    2
    


```python
p2 = eval(v)
```


```python
print( p2.name, p2.age, p2.address )
```

    홍길동 23 서울
    


```python
# __repr__ : 객체-값 => 값의 표현식을 문자열로 반환. 30 -> '30', True -> 'True'
# Square 객체(값) - Square(30) -> 'Square(30)'
# Person('히나',24,'서울') -> 'Person('히나',24,'서울')'
# Person('이순신'10,'인천') -> 'Person('이순신'10,'인천')'
```


```python
print("Hello World") # 값을 문자열로 변환해서 출력
'Hello World' #=> print(" 'Hello World' ") # 값의 표현식을 출력 -> __repr__() 반환값을 출력
```

    Hello World
    




    'Hello World'




```python
ss = repr('h')
```


```python
print(ss)
```

    'h'
    


```python
print(len(ss)) # '3' => 작은 따움표 개수 포함
```

    3
    

#### 연산자 재정의(Operator overriding) 관련 특수 메소드
- 연산자의 피연산자로 객체를 사용하면 호출되는 메소드들
- 다항연산자일 경우 가장 왼쪽의 객체에 정의된 메소드가 호출된다.
    - `a + b` 일경우 a의 `__add__()` 가 호출된다.
- **비교 연산자**
    = p1.__eq__(p2) -> p1 안의 메소드를 만들어야함
    - **`__eq__(self, other)`** : self == other
        - == 로 객체의 내용을 비교할 때 정의 한다.
    - **`__lt__(self, other)`** : self < other, 
    - **`__gt__(self, other)`**: self > other
        - min()이나 max()에서 인수로 사용할 경우 정의해야 한다.
    - **`__le__(self, other)`**: self <= other
    - **`__ge__(self, other)`**: self >= other
    - **`__ne__(self, other)`**: self != other

- **산술 연산자**
    - **`__add__(self, other)`**: self + other
    - **`__sub__(self, other)`**: self - other
    - **`__mul__(self, other)`**: self * other
    - **`__truediv__(self, other)`**: self / other
    - **`__floordiv__(self, other)`**: self // other
    - **`__mod__(self, other)`**: self % other


```python
class Person:
    def __init__(self,name,age,address):
        self.name = name
        self.age = age
        self.address = address
    def __repr__(self):
        return f"Person('{self.name}',{self.age},'{self.address}')"
    def __str__(self): # 많이 함 어떤 인스턴스 문자열로 구성되는지
        return f"이름:{self.name}\n나이:{self.age}\n주소:{self.address}"
    
    def __eq__(self, other):
        # self == other 연산시 호출됨. - 속성값이 같으면 True가 나오도록 처리.
        if isinstance(other,Person):
            return self.name == other.name and self.age == other.age and self.address == other.address
        else:
            return False
        
    def __gt__(self,other):
        # self > other 연산시 호출 - 나이 비교
        ## 구현 하는건 사람 마다 필요한 것만 코딩함
        if isinstance(other,Person): # 
            return self.age > other.age # other.age : 객체
        elif isinstance(other, (int,float)):    
            # self > 30 , self > 25.4
            return self. age > other # other 정수
        else:
#             return False
            # 에러 ( Exception ) 을 발생
            raise TypeError(f"Person 타입과 {type(other)}는 '>' 연산을 할수 없습니다")

```


```python
# p1.__add__(p2) , p1 + -> Person class 안에 있어야함
# __eq__()
p1 = Person('홍길동',23,'서울')
p2 = Person('유재석',20,'인천')
p4 = Person('정준하',23,'부산')
p5 = Person('홍길동',40,'부산')
```


```python
print( p1 == p5 ) # name 값이 같아도 다른 값들이 틀리면 False
```

    False
    


```python
print( p1 != p4 )
```

    True
    


```python
# __gt__() 
print( p1 > p2 )
```

    True
    


```python
print( p1 < p2 )
```

    False
    


```python
# p1의 나이가 10보다 큰지?
print( p1 > 10)
```

    True
    


```python
print( p1 > 14.5 )
```

    True
    


```python
print( p1 > 100)
```

    False
    


```python
p1 > '스무살'
# Raise : TypeError: Person 타입과 <class 'str'>는 '>' 연산을 할수 없습니다
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    Cell In[256], line 1
    ----> 1 p1 > '스무살'
    

    Cell In[235], line 29, in Person.__gt__(self, other)
         25             return self. age > other # other 정수
         26         else:
         27 #             return False
         28             # 에러 ( Exception ) 을 발생
    ---> 29             raise TypeError(f"Person 타입과 {type(other)}는 '>' 연산을 할수 없습니다")
    

    TypeError: Person 타입과 <class 'str'>는 '>' 연산을 할수 없습니다


# class변수, class 메소드
- **class변수**
    - (Intance가 아닌) 클래스 자체의 데이터
    - Attribute가 객체별로 생성된다면, class변수는 클래스당 하나가 생성된다.
    - 구현
        - class 블럭에 변수 선언.
- **class 메소드**
    - 클래스 변수를 처리하는 메소드
    - 구현
        - @classmethod 데코레이터를 붙인다.
        - 첫번째 매개변수로 클래스를 받는 변수를 선언한다. 이 변수를 이용해 클래스 변수나 다른 클래스 메소드를 호출 한다.

# static 메소드
- 클래스의 메소드로 클래스 변수와 상관없는 단순기능을 정의한다.
    - Caller 에서 받은 argument만 가지고 일하는 메소드를 구현한다.
- 구현
    - @staticmethod 데코레이터를 붙인다.
    - Parameter에 대한 규칙은 없이 필요한 변수들만 선언한다.
    

## class 메소드/변수, static 메소드 호출
- 클래스이름.변수
- 클래스이름.메소드() 


```python
class Circle:
    __PI = 3.14 # class의 변수 - class variavle ( class block 변수)
    # __변수 : 은닉 -> Circle__PI 로 변경됨
    # pi의 값을 변경( setter ), 조회( getter )
    @classmethod
    def set_PI(clazz, new_PI): # 첫번째 파라미터 - class 자체를 받는다. Circle.set_PI(3.14)
        # clazz -> class 변수, 다른 class 메소드를 호출할 때 사용.
        if new_PI in [ 3.14, 3.14159 ]:
            clazz.__PI = new_PI
        else:
            print('변경 못함 현재 PI값:', clazz.__PI)
    @classmethod
    def get_PI(clazz):
        return clazz.__PI
    
    def __init__(self, radius):
        # self -> attribute(instance 변수), instance method 호출
        self.radius = radius 
    def calc_area(self): # 원의 널비
        return self.radius * self.radius * Circle.__PI # method 에서 class 변수 사용
    
    @staticmethod
    def class_version():
        # class 변수나 instance 변수를 사용하지 않는 메소드.
        # 함수처럼 사용하는 메소드 ( 클래스 소속. )
        return '1.0'
    
```


```python
c = Circle(5)
```


```python
print(c.calc_area())
```

    78.5
    


```python
# class 변수 조회
# print(Circle.PI)
print(Circle.get_PI())
```

    3.14
    


```python
Circle.class_version()
```




    '1.0'




```python
Circle.set_PI(3.145)
```

    변경 못함 현재 PI값: 3.14
    


```python
# class 변수 변경
Circle.PI = 3.1415
```


```python
print(Circle._Circle__PI)
```

    3.14
    


```python
print(c.calc_area())
```

    78.5
    
