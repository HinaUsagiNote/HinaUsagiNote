---
layout: single
title: '변수와 연산자'
typora-root-url: ../
---

# 자료구조란

- 여러 개의 값들을 모아서 관리하는 데이터 타입.
    - 한 개의 변수는 한 개의 값 밖에는 가지지 못한다. 그러나 하나의 변수로 여러 개의 값 묶어서 저장해 관리해야 할 경우가 있다. 
- 파이썬은 데이터를 모으는 방식에 따라 다음과 같이 4개의 타입을 제공한다.
    - List : 순서가 있으며 중복된 값들을 모으는 것을 허용하고 구성하는 값들(원소)을 변경할 수 있다.
    - Tuple : 순서가 있으며 중복된 값들을 모으는 것을 허용하는데 구성하는 값들을 변경할 수 없다.
    - Dictionary : key-value 형태로 값들을 저장해 관리한다.
    - Set : 중복을 허용하지 않고 값들의 순서가 없다.
- 원소, 성분, 요소, element
    - len(자료구조) 함수
        - 자료구조 내의 원소의 개수를 반환한다.

## List


```python
l1 = [10, 20, 30, 40, 50]
```


```python
print(l1)
```

    [10, 20, 30, 40, 50]
    


```python
print(type(l1))
```

    <class 'list'>
    


```python
# 다른 타입의 값들을 모을수 있다
l2 = [ 'a', 20, 1.2, True ] 
print(l2)
```

    ['a', 20, 1.2, True]
    


```python
# 빈 리스트를 만들 수있음
l3 = [] 
print(l3)
```

    []
    

## Indexing과 Slicing을 이용한 원소(element) 조회 및 변경

### Indexing
- 하나의 원소를 조회하거나 변경할 때 사용
- 리스트\[index\] 
    - index의 원소를 조회
- 리스트\[index\] = 값
    - index의 원소를 변경


```python
l1 = [1, 2, 3, 4, 5 ]
```


```python
# 2번째 index 값 => 6 변경
l1[2] = 6 
print(l1)
```

    [1, 2, 6, 4, 5]
    

### Slicing
- 범위로 조회하거나 그 범위의 값들을 변경한다.
- 기본구문: **리스트\[ 시작 index : 종료 index : 간격\]**
    - 시작 index ~ (종료 index – 1)
    - 간격을 지정하면 간격만큼 index를 증/감한다. (생략 시 1이 기본 간격)
#### slicing을 이용한 값 변경
- slicing 을 이용할 경우 slicing된 원소 개수와 동일한 개수의 값들을 대입한다.
    - `리스트[1:5] = 10,20,30,40` : index 1, 2, 3, 4의 값을 각각 10, 20, 30, 40 으로 변경


```python
# indexsing - 리스트에서 원소(값) 한개만 조회
l1 = [1, 2, 3, 4, 5 ]
```


```python
# 원소값의 갯수 5개
print(len(l1)) 
print(l1)
```

    5
    [1, 2, 3, 4, 5]
    


```python
# 0 ~뒤에서 2번째 index
print( l1[0], l1[-2] ) 
```

    1 4
    


```python
# 2 ~ 뒤에서 1번째 index
print( l1[2], l1[-1] ) 
```

    3 5
    


```python
# 0번째 Index => 100으로 변경
l1[0] = 100 
print(l1)
```

    [100, 2, 3, 4, 5]
    


```python
# 뒤에서 1번째 Index -100으로 변경
l1[-1] = -100  
print(l1)
```

    [100, 2, 3, 4, -100]
    


```python
# l1에 뒤에서 1번째 Index 삭제
del l1[-1] 
```


```python
# 마지막 Index에 100000 추가
l1.append(10000) 
```


```python
print(l1)
```

    [100, 2, 3, 4, 10000]
    


```python
# slicing
l2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```


```python
# l2 안에 들어가 있는 원소 개수
print(len(l2)) 
```

    10
    


```python
# Index를 조회할때는 0부터 조회한다
## 1 ~ 6 번째 index 조회
print(l2[ 1 : 6]) 
```

    [1, 2, 3, 4, 5]
    


```python
# 1 ~ 8 번째 index 간격 : 3 
print(l2[ 1 : 8 : 3]) 
```

    [1, 4, 7]
    


```python
# 첫번째 (생략가능) ~ 5 번째 index 
print(l2[ : 5 ]) 
```

    [0, 1, 2, 3, 4]
    


```python
# 5 ~ 마지막번째 index 
print(l2[ 5 : ]) 
```

    [5, 6, 7, 8, 9]
    


```python
# 2 ~ 마지막 Index까지 간격 : 2
print(l2[ 2 : : 2]) 
```

    [2, 4, 6, 8]
    


```python
# 1 ~ 뒤에서 2번째 Index
print(l2[ 1 : -1 ]) 
```

    [1, 2, 3, 4, 5, 6, 7, 8]
    


```python
# 역순 
print(l2[ : : -1]) 
```

    [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
    


```python
# 2 ~ 5 index사이의 값들을 각각 20, 30 40 값 변경
l2[ 2 : 5 ] = [ 20, 30, 40] 
print(l2)
```

    [0, 1, 20, 30, 40, 5, 6, 7, 8, 9]
    


```python
# 6 ~ 7 Index 값을 각각 1000, 2000 값 변경
l2[ 6 : ] = [ 1000, 2000] 
print(l2)
```

    [0, 1, 20, 30, 40, 5, 1000, 2000]
    

## List 연산자
- 리스트 + 리스트
    - 두 리스트의 원소들을 합친 리스트를 반환한다.
- 리스트 * 정수
    - 같은 리스트의 원소들을 정수번 합친 리스트를 반환한다.   
- in, not in 연산자
    - 값 in 리스트
        - 리스트의 원소로 값이 **있으면** True, 없으면 False 반환
    - 값 not in 리스트
        - 리스트의 원소로 값이 **없으면** True, 있으면 False 반환  
- len(리스트)
    - 리스트 내의 원소수를 반환.        


```python
l1 = [ 1, 2, 3]
l2 = [ 100, 200, 300, 400]
```


```python
# 두 리스트를 합침
l3 = l1 + l2 
print(l3)
```

    [1, 2, 3, 100, 200, 300, 400]
    


```python
print(l1, l2)
```

    [1, 2, 3] [100, 200, 300, 400]
    


```python
# l1의 원소들 * 3
l4 = l1 * 3 
print(l4)
```

    [1, 2, 3, 1, 2, 3, 1, 2, 3]
    


```python
l1 = [ 1, 2, 3]
```


```python
# l1에 10이 있는지
print(10 in l1) 
# l1에 10이 없는지
print(10 not in l1)
```

    False
    True
    


```python
# l1에 [ 1, 2 ] 리스트가 있는지
print([ 1, 2 ] in l1 ) 
```

    False
    


```python
# l1 안에 1 또는 2가 있는지?
print( 1 in l1 or 2 in l1 ) 
```

    True
    


```python
# l1 안에 1 , 20이 있는지?
print( 1 in l1 and 20 in l1 ) 
```

    False
    

## 중첩 리스트 (Nested List)
- List가 원소로 List를 가지는 것을 말한다.
    - List를 포함한 모든 자료구조 타입들도 다 값이므로 다른 자료구조의 원소로 들어갈 수 있다.    


```python
l1 = [ 1, 2, 3 ]
l2 = [ '가', '나', '다', '라']
l3 = [ l1 , l2 ]
```


```python
print( l3 )
```

    [[1, 2, 3], ['가', '나', '다', '라']]
    


```python
# 두개의 리스트를 합친 후 값을 찾을 때 순서대로 박스 안에 들어가는 개념으로 찾아야함
print( l3 [0] [1] ) 
```

    2
    


```python
print( l3 [1] [2] )
```

    다
    

## List 대입
- 리스트의 원소들을 각각 다른 변수에 대입하는 표현식
- 변수의 개수와 리스트 원소의 개수는 동일해야 한다.


```python
# 리스트 원소랑 개수가 동일해야함
# 리스트 대입
v1, v2, v3 = [10, 20, 30] 
print(v1, v2, v3)
```

    10 20 30
    


```python
# 튜플대입
v11, v22, v33 = 1, 2, 3 
print(v11, v22, v33 )
```

    1 2 3
    

## List 주요 메소드


```python
l1 = [ 1, 2, 3, 4, 5, 6, 7]
```


```python
# 10을 추가 => 계속 추가됨
l1.append(10) 
```


```python
print(l1)
```

    [1, 2, 3, 4, 5, 6, 7, 10]
    


```python
# 100, 200, 300을 마지막번째에 추가
l1.extend([100, 200, 300])
print(l1)
```

    [1, 2, 3, 4, 5, 6, 7, 10, 100, 200, 300]
    


```python
# index 3에 10000을 삽임
l1.insert(3, 10000) 
print(l1)
```

    [1, 2, 3, 10000, 4, 5, 6, 7, 10, 100, 200, 300]
    


```python
results = []

results.append( 1 + 1 )
results.append( 10 * 2 )
results.append( 100 / 5 )

print(results)
```

    [2, 20, 20.0]
    


```python
# l1의 원소들을 오름차순 정령
l1.sort() 
print(l1)
```

    [1, 2, 3, 4, 5, 6, 7, 10, 100, 200, 300, 10000]
    


```python
# 내림차순 정령
l1.sort(reverse=True) 
print(l1)
```

    [10000, 300, 200, 100, 10, 7, 6, 5, 4, 3, 2, 1]
    


```python
# 정렬 함수 : sorted(자료구조) => 정렬 결과를 리스트로 반환
## l1 자체를 정렬하지 않음 새로운 리스트를 담아서 반환
print(sorted(l1)) 
```

    [1, 2, 3, 4, 5, 6, 7, 10, 100, 200, 300, 10000]
    


```python
# 문자열을 하나씩 쪼갠다
sorted('가ABcd' , reverse=True)
```




    ['가', 'd', 'c', 'B', 'A']




```python
# 삭제
## 300을 찾아서 삭제
l1.remove(300) 
```


```python
print(l1)
```

    [10000, 200, 100, 10, 7, 6, 5, 4, 3, 2, 1]
    


```python
# v = index 3번째의 값을 반환하면서 삭제
v = l1.pop(3) 
```


```python
print(l1)
```

    [10000, 200, 100, 7, 6, 5, 4, 3, 2, 1]
    


```python
print(v)
```

    10
    


```python
# 마지막 index의 값을 삭제하면서 반환. (index생략)
v2 = l1.pop() 
print(v2)
```

    1
    


```python
print(l1)
```

    [10000, 200, 100, 7, 6, 5, 4, 3, 2]
    


```python
# 마지막 index 반환 후 삭제
print(l1.pop())
```

    2
    


```python
# 모든걸 삭제한다
l1.clear() 
print(l1)
```

    []
    


```python
l = [ 1, 2, 3]
```


```python
# 없는 index 다루기 => 없는 index 조회 ==> Error
l[5] 
```


```python
# indexError
l.pop(10)
```


```python
# 없는 index에 넣으면 append()가 된다
l.insert(11) 
```


```python
print(l)
```

    [1, 2, 3, 11]
    

# Tuple (튜플)
- List와 같이 순서대로 원소들을 관리한다. 단 저장된 원소를 변경할 수 없다.
- Tuple 은 각 위치(Index) 마다 정해진 의미가 있고 그 값이 한번 설정되면 바뀌지 않는 경우에 사용한다. 
    - Tuple은 값의 변경되지 않으므로 안전하다.


```python
# 생성
## () 감싼다
t1 = ( 10, 20, 30, 40, 50 ) 
print(type(t1))
```

    <class 'tuple'>
    


```python
# ( ) 생략 가능
t2 = 10, 20, 30, 40, 50, 60 
print(type(t2))
```

    <class 'tuple'>
    


```python
# ( ) 생략, 다른 타입을 모을수 있다
t3 = 10, 5.2, True, 'abc' 
print(type(t3))
```

    <class 'tuple'>
    


```python
# 원소가 1개인 Tuple
## ,쉼표를 찍지 않아서 int 타입으로 나옴
t4 = (30) 
print(type(t4))
```

    <class 'int'>
    


```python
# ( ) 괄호생략가능 , 쉼표를 찍어야지 원소가 한개인 Tuple을 생성가능
t5 = (30 ,) 
print(type(t5))
```

    <class 'tuple'>
    

## Indexing과 Slicing을 이용한 원소(element) 조회
- 리스트와 동일하다.
- 단 튜플은 조회만 가능하고 원소를 변경할 수 없다.


```python
t2 = 10, 20, 30, 40, 50, 60
```


```python
print(t2)
```

    (10, 20, 30, 40, 50, 60)
    


```python
# 앞에서 1번째 index
print(t2[0])
```

    10
    


```python
# 앞에서 5번째, 뒤에서 1번째 index
print(t2[5], t2[-1]) 
```

    60 60
    


```python
# 앞에서 1번째 ~ 5번째 index
print(t2[ 1 : 5])
```

    (20, 30, 40, 50)
    


```python
# 앞에서 1번째 ~ 뒤에서 2번째 index
print(t2[ 1 : -2 ])
```

    (20, 30, 40)
    


```python
# 1번째 index ~ 끝까지, 간격: 3
print(t2[ : : 3 ])
```

    (10, 40)
    


```python
# 역순
print(t2[ : : -1 ]) 
```

    (60, 50, 40, 30, 20, 10)
    


```python
# Tuple은 원소 변경 안됨 => Error
t2[2] = 100
```

## Tuple 연산자
- tuple + tuple
    - 두 tuple의 원소들을 합친 tuple을 반환한다.
- tuple * 정수
    - 같은 tuple의 원소들을 정수번 합친 tuple를 반환한다.  
- in, not in 연산자
    - 값 in tuple
        - tuple의 원소로 값이 **있으면** True, 없으면 False 반환
    - 값 not in tuple
        - tuple의 원소로 값이 **없으면** True, 있으면 False 반환    
- len(tuple)
    - tuple의 원소 개수 반환        


```python
t1 = ( 10, 20, 30, 40, 50 )
t2 = 10, 20, 30, 40, 50, 60
```


```python
r1 = t1 + t2
print(r1)
```

    (10, 20, 30, 40, 50, 10, 20, 30, 40, 50, 60)
    


```python
# 튜플 타입
print(t1 , t2) 
```

    (10, 20, 30, 40, 50) (10, 20, 30, 40, 50, 60)
    


```python
print( t1 * 5 )
```

    (10, 20, 30, 40, 50, 10, 20, 30, 40, 50, 10, 20, 30, 40, 50, 10, 20, 30, 40, 50, 10, 20, 30, 40, 50)
    


```python
print(10 in t2, 100 in t2)
```

    True False
    


```python
print(10 not in t2, 100 not in t2)
```

    False True
    


```python
t2 = 10, 20, 30, 40, 50, 60
t3 = 10, 5.2, True, 'abc'
```


```python
print(len(t2), len(t3))
```

    6 4
    

## Tuple 대입
- 튜플의 원소들을 각각 다른 변수에 대입하는 표현식.
- 변수의 개수와 튜플의 원소 개수는 동일해야 한다.


```python
# ( ) 생략함 , 변수와 값의 갯수가 똑같아야함
v1, v2, v3 = 10, 'a', 5.7 
print(v1,v2,v3)
```

    10 a 5.7
    

## Tuple의 주요 메소드
|메소드|설명|
|:-|-|
|index(찾을값 \[, 시작index\])|'찾을값'이 몇번 index인지 반환한다.|
|count(값)|원소로 '값'이 몇개 있는지 반환한다.|


```python
# 문법적으로는 ( ) 괄호를 사용
t = 1, 2, 3, 4, 1, 2, 1, 2, 1, 1,
```


```python
print(t)
```

    (1, 2, 3, 4, 1, 2, 1, 2, 1, 1)
    


```python
# 값 4의 인덱스 조회 
print( t.index(4) ) 
```

    3
    


```python
# 중복된 값의 index , 가장 먼저 있는 index 출력
print( t.index(2)) 
```

    1
    


```python
# 찾을값 : 2,  시작index : 4 ( 찾기 시작위치 4번째 index )
print( t.index( 2 , 4 )) 
```

    5
    


```python
# 1이 몇개있는지
print( t.count(1)) 
```

    5
    

# Dictionary
- 값을 키(key)-값(value) 쌍으로 묶어서 저장하는 자료구조이다.
    - 리스트나 튜플의 index의 역할을 하는 key를 직접 지정한다.
    - 서로 의미가 다른 값들을 하나로 묶을 때 그 값의 의미를 key로 가질 수 있는 dictionary를 사용한다.


```python
# 물건의 개수
fruit_counts = { '사과':100, '배':50, '수박':60, '귤':70 }
print(fruit_counts)
```

    {'사과': 100, '배': 50, '수박': 60, '귤': 70}
    


```python
# key는 중복 허용 안함 value는 중복 허용
d = {'name':'홍길동','nickname':'홍길동'}
print(d)
```

    {'name': '홍길동', 'nickname': '홍길동'}
    


```python
# 같은 key가 들어가면 마지막에 추가된 것만 남음 (변경)
d1 = {'name':'홍길동','name':'박명수', 'name':'유재석'}
print(d1) 
```

    {'name': '유재석'}
    


```python
customer_info2 = dict(id='id-1900', password='dlfwlssla', name='홍길동')
print(customer_info2)
```

    {'id': 'id-1900', 'password': 'dlfwlssla', 'name': '홍길동'}
    

## Dictionary 원소 조회 및 변경
- 조회: index에 key값을 식별자로 지정한다.
    - dictionary\[ key \]
    - 없는 키로 조회 시 KeyError 발생
- 변경
    - dictionary\[ key \] = 값
    - 있는 key값에 값을 대입하면 변경이고 없는 key 일 경우는 새로운 item을 추가하는 것이다.


```python
customer_info = { 'name':'홍길동', 
                 'age':20, 
                 'email':'abc@abc.com', 
                 'address':'서울',
                 'hobby':['게임','스포츠']}
```


```python
# 키 값은 무조건 문자열 '',""
print(customer_info)
```

    {'name': '홍길동', 'age': 20, 'email': 'abc@abc.com', 'address': '서울', 'hobby': ['게임', '스포츠']}
    


```python
# 이름 , 취미
print(customer_info['name'])
print(customer_info['hobby'])
```

    홍길동
    ['게임', '스포츠']
    


```python
# 취미 2번쨰
print(customer_info['hobby'][0])
```

    게임
    


```python
# 추가 / 변경
## item을 추가
customer_info['tall'] = 175.33 # 없는 키 = 값 => 추가 가능
print(customer_info)
```

    {'name': '홍길동', 'age': 20, 'email': 'abc@abc.com', 'address': '서울', 'hobby': ['게임', '스포츠'], 'tall': 175.33}
    


```python
customer_info['age'] = 30
print(customer_info) # 있는 Key에 값을 할당
```

    {'name': '홍길동', 'age': 30, 'email': 'abc@abc.com', 'address': '서울', 'hobby': ['게임', '스포츠'], 'tall': 175.33}
    

## Dictionary 연산자

- in, not in 연산자
    - 값 in dictionary
        - dictionary의 **Key**로 값이 **있으면** True, 없으면 False 반환
    - 값 not in dictionary
        - dictionary의 **Key**로 값이 **없으면** True, 있으면 False 반환    
- len(dictionary)
    - dictionary의 **Item의 개수** 반환        


```python
# in , not in 은 key가 있는지/없는지 여부
# key가 아님
print('홍길동' in customer_info) 
```

    False
    


```python
# key가 맞음
print('name' in customer_info) 
```

    True
    


```python
# weight 키가 있으면 조회
if'weight' in customer_info:  
    print(customer_info['weight']) 
# weight 키가 없으면 실행
else:
    print('몸무게 없음') 
```

    몸무게 없음
    

## Dictionary 주요 메소드



```python
print(customer_info)
```

    {'name': '홍길동', 'age': 30, 'email': 'abc@abc.com', 'address': '서울', 'hobby': ['게임', '스포츠'], 'tall': 175.33}
    


```python
# 없는 키 에러
print(customer_info['weight']) 
```


```python
# 없는 키는 None을 반환 
print(customer_info.get('weight')) 
```

    None
    


```python
# -1 : deaoult 값 (weight 키가 없으면 반환할 값)
print(customer_info.get('weight', -1)) 
```

    -1
    


```python
# address의 값을 반환하면서 제거
v = customer_info.pop('address') 
print(v, customer_info)
```

    서울 {'name': '홍길동', 'age': 30, 'email': 'abc@abc.com', 'hobby': ['게임', '스포츠'], 'tall': 175.33}
    


```python
# 삭제
del customer_info['email'] 
```


```python
print(customer_info)
```

    {'name': '홍길동', 'age': 30, 'hobby': ['게임', '스포츠'], 'tall': 175.33}
    


```python
# key 값들만 모아서 반환
print(customer_info.keys()) 
```

    dict_keys(['name', 'age', 'hobby', 'tall'])
    


```python
# value들만 모아서 반환
print(customer_info.values()) 
```

    dict_values(['홍길동', 30, ['게임', '스포츠'], 175.33])
    


```python
# key, value를 묶어서 반환
print(customer_info.items()) 
```

    dict_items([('name', '홍길동'), ('age', 30), ('hobby', ['게임', '스포츠']), ('tall', 175.33)])
    


```python
# 다 지움
customer_info.clear() 
```


```python
print(customer_info)
```

    {}
    

# Set 

- Set은 중복되는 값을 허용하지 않고 순서를 신경 쓰지 않는다.
    - 원소를 식별할 수 있는 식별자가 없기 때문에 Set은 indexing과 slicing을 지원하지 않는다


```python
s1 = {1, 2, 3, 4, 5,}
print(s1)
```

    {1, 2, 3, 4, 5}
    


```python
# 중복된 값 제거 , 순서 상관없이 출력
s2 = {1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5} 
print(s2)
```

    {1, 2, 3, 4, 5}
    


```python
# 개별 원소를 조회할수 없다
print(s2[0]) 
```

## Set 연산자

- in, not in 연산자
    - 값 in Set
        - Set의 원소로 값이 **있으면** True, 없으면 False 반환
    - 값 not in Set
        - Set의 원소로 값이 **없으면** True, 있으면 False 반환    
- len(Set)
    - Set의 **원소의 개수** 반환        


```python
s2 = {1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5}
```


```python
print(10 in s2)
```

    False
    


```python
print(1 in s2)
```

    True
    


```python
print(10 not in s2, 1 not in s2)
```

    True False
    


```python
print(len(s2))
```

    5
    

## Set의 주요 메소드



```python
s2 = {1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5}
```


```python
# 추가
print(s2.add(6)) 
print(s2)
```

    None
    {1, 2, 3, 4, 5, 6}
    


```python
# 여러가지 값 추가
s2.update([10, 20, 30,40]) 
print(s2)
```

    {1, 2, 3, 4, 5, 6, 10, 20, 30, 40}
    


```python
# 있는 값은 중복되서 추가안됨
s2.update([100, 200, 300, 10, 20, 30, 40]) 
print(s2)
```

    {1, 2, 3, 4, 5, 6, 200, 10, 20, 30, 100, 40, 300}
    


```python
# 1번째 index 반환후 삭제
v = s2.pop()
```


```python
print(v)
```

    1
    


```python
print(s2)
```

    {2, 3, 4, 5, 6, 200, 10, 20, 30, 100, 40, 300}
    


```python
# 없는 값 삭제 -> 예외(Exception) 발생
s2.remove(20) 
```


```python
print(s2)
```

    {2, 3, 4, 5, 6, 200, 10, 30, 100, 40, 300}
    

## Set의 집합연산 연산자 및 메소드

- 합집합
    - 집합A | 집합B
    - 집합A.union(집합B)
- 교집합
    - 집합A & 집합B
    - 집합A.intersection(집합B)
- 차집합
    - 집합A - 집합B
    - 집합A.difference(집합B)


```python
set1 = {1, 2, 3, 4, 5}
set2 = {4, 5, 6, 7, 8}
print(set1)
print(set2)
```

    {1, 2, 3, 4, 5}
    {4, 5, 6, 7, 8}
    


```python
# 합집합
## set1 , set2 두 set을 합친 새로운 set 반환
set3 = set1 | set2 
# set = set1.union(set2)
print(set3)
```

    {1, 2, 3, 4, 5, 6, 7, 8}
    


```python
# 교집합
set4 = set1 & set2
# set4 = set1. intersection(set2)
print(set4)
```

    {4, 5}
    


```python
set5 = set1 - set2
# set5 = set1.difference(set2)
print(set5)
```

    {1, 2, 3}
    

# 자료구조 변환 함수

- list(자료구조)
    - 대상 자료구조/Iterable을 List로 변환한다.
- tuple(자료구조)
    - 대상 자료구조/Iterable을 Tuple로 변환
- set(자료구조)
    - 대상 자료구조/Iterable을 Set으로 변환
    - 다른 자료구조의 원소 중 중복을 빼고 조회할 때 set()를 이용해 Set으로 변환한다.
- Dictionary로 변환하는 함수는 없다.
- 변경할 대상이 Dictionary 일 경우에는 key값들만 모아서 변환한다.



```python
v = [1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 5, 5]
print(v)
```

    [1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 5, 5]
    


```python
# v 가 무슨 값들로 구성되어 있는지 확인
print(set(v))
print(v)
```

    {1, 2, 3, 4, 5}
    [1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 5, 5]
    


```python
t = (1, 2, 3, 4, 5)
```


```python
# t에 100을 추가 : tuple -> list -> 값 추가 -> tuple
## l 에 t를 넣어서 리스트를 만듬
l = list(t) 
print(l)
```

    [1, 2, 3, 4, 5]
    


```python
# list 에 100을 추가 
l.append(100) 
print(l)
```

    [1, 2, 3, 4, 5, 100]
    


```python
# l을 tuple로 만들어서 t에 넣음
t = tuple(l) 
print(t)
```

    (1, 2, 3, 4, 5, 100)
    


```python
d = {'A':10, 'B':20, 'C':30}
print(d)
```

    {'A': 10, 'B': 20, 'C': 30}
    


```python
# set로 변경
print(set(d)) 
```

    {'A', 'C', 'B'}
    


```python
# list로 변경
print(list(d)) 
```

    ['A', 'B', 'C']
    


```python
# tuple로 변경
print(tuple(d)) 
```

    ('A', 'B', 'C')
    


```python
# 문자열 : 문자를 모아놓은 iterable
print(list('안녕하세요.'))
```

    ['안', '녕', '하', '세', '요', '.']
    


```python
print(set('aaaaaabbbcccccddddedacse')) 
```

    {'s', 'e', 'a', 'd', 'c', 'b'}
    


```python
print(tuple('안녕하세요.'))
```

    ('안', '녕', '하', '세', '요', '.')
    


```python
r = '배 사과 귤 수박 복숭아'.split()
print(r)
```

    ['배', '사과', '귤', '수박', '복숭아']
    


```python
# '합칠때 사용할 구분문자열'.join(리스트) -> 리스트의 문자열 원소들을 하나의 문자열로 합친다.
print(''.join(r)) 
```

    배사과귤수박복숭아
    


```python
print('-'.join(r))
```

    배-사과-귤-수박-복숭아
    

# 실습예제


```python
# 문제 1 ~ 7
jumsu = [100, 90, 100, 80, 70, 100, 80, 90, 95, 85] 
# 위 리스트는 학생번호 1번 ~ 10번까지 10명의 시험 점수이다. 
```


```python
#(1)  7번의 점수를 출력하세요 
print(jumsu[6])
```

    80
    


```python
#(2)  1번부터 5번까지의 점수를 출력하세요.
print(jumsu[ : 5])
```

    [100, 90, 100, 80, 70]
    


```python
#(3)  4, 5, 6, 7번의 점수를 출력하세요.
print(jumsu[ 3 : 7] )
```

    [80, 70, 100, 80]
    


```python
#(4) 짝수번째 점수를 출력하세요.
print(jumsu[ 1 :: 2])
```

    [90, 80, 100, 90, 85]
    


```python
#(5) 홀수번째 점수를 출력하세요.
print(jumsu[ : : 2 ] )
```

    [100, 100, 70, 80, 95]
    


```python
#(6) 9번의 점수를 20으로 변경하고 전체 출력하세요.
jumsu[-2] = 20
print(jumsu)
```

    [100, 90, 100, 80, 70, 100, 80, 90, 20, 85]
    


```python
#(7) 중복된 점수는 제거하고 하나씩만 나오도록 출력하세요.
# list를 set 으로 바꾸면서 set의 중복된 값 제거
set(jumsu) 
print(jumsu)
# list(set(jumsu)) # set()으로 중복을 제거 하고 그 결과를 리스트로 변환
```

    [100, 90, 100, 80, 70, 100, 80, 90, 20, 85]
    


```python
# 문제 8 ~ 9
fruits = ["복숭아", "수박", "딸기"]
```


```python
#(8) fruits 리스트에 마지막 원소로 "사과", "귤"을 추가하세요.
fruits.append("사과")
fruits.append("귤")
# fruits.extend(['사과','귤']) # 동시에 추가할때 .extend([])
print(fruits)
```

    ['복숭아', '수박', '딸기', '사과', '귤']
    


```python
#(9) fruits 리스트에서 "복숭아"를 제거하세요.
# del , pop 메소드 사용 가능
fruits.remove("복숭아")
print(fruits)
```

    ['수박', '딸기', '사과', '귤']
    


```python
# 문제 10 ~ 15
#(10)본인의 이름, 나이, email주소, 취미, 결혼유무를 사전(딕셔너리)으로 생성. 
# 취미는 2개 이상의 값을 넣는다..
person = dict( 이름='홍길동', 나이=25, email주소='a@a.com', 취미=['음악','스포츠'], 결혼여부=False )
print(person)
```

    {'이름': '홍길동', '나이': 25, 'email주소': 'a@a.com', '취미': ['음악', '스포츠'], '결혼여부': False}
    


```python
#(11) 위 딕셔너리에서 이름과 email주소를 조회해서 출력하세요.
print(person['이름'])
print(person['email주소'])
```

    홍길동
    a@a.com
    


```python
#(12) 위 딕셔너리에서 취미중 두번째 취미를 조회해서 출력하세요.
print(person['취미'][1])
```

    스포츠
    


```python
#(13) 위 딕셔너리에 몸무게와 키 항목을 추가하세요.
person['몸무게'] = 80
person['키'] = 175
print(person)
```

    {'이름': '홍길동', '나이': 25, 'email주소': 'a@a.com', '취미': ['음악', '스포츠'], '결혼여부': False, '몸무게': 80, '키': 175}
    


```python
#(14) 위 딕셔너리에서 나이를 제거하세요.
del person['나이']
print(person)
```

    {'이름': '홍길동', 'email주소': 'a@a.com', '취미': ['음악', '스포츠'], '결혼여부': False, '몸무게': 80, '키': 175}
    


```python
#(15) 위 딕셔너리에서 email 주소를 다른 값으로 변경하세요.
person['email주소'] = 'karen@karen.com'
print(person)
```

    {'이름': '홍길동', 'email주소': 'karen@karen.com', '취미': ['음악', '스포츠'], '결혼여부': False, '몸무게': 80, '키': 175}
    
