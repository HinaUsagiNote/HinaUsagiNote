---
layout: single
title: 'Iterable과 Decorator'
typora-root-url: ../
---

# Iterable과 Iterator

- **Iterable**
    - 여러개의 데이터를 하나씩 또는 한 단위씩 제공하는 객체.
        - 다음 작업을 요청하면 값을 제공하며 for in 문에서 사용할 수 있다.
    - Iterator객체를 반환하는 `__iter__()` 특수 메소드를 정의해야 한다.
        - `__iter__()`는 `iter(Iterable)` 내장함수에 의해 호출된다. 
- **Iterator**
    - 자신을 생성한 Iterable의 값들을 하나씩 또는 한 단위씩 제공하는 객체
    - Iterable의 값을 제공하는 `__next__()` 특수 메소드를 정의한다.
        - `__next__()` 는 `next(Iterator)` 내정함수에 의해 호출된다.
        - 더 이상 제공할 값이 없을 경우 **StopIteration** Exception을 발생시켜야 한다.


```python
l = [1, 2, 3]  # 리스트 > list --> iterable > __iter__() 구현
l_iterator = iter(l) # iter(iterable객체) -> iterable객체.__iter__()

print(type(l), type(l_iterator))
```

    <class 'list'> <class 'list_iterator'>
    


```python
# l.__iter__()
```




    <list_iterator at 0x215ccdbdd20>




```python
t = (1, 2, 3, 4)
t_iterator = iter(t)
print(type(t_iterator))
```

    <class 'tuple_iterator'>
    


```python
# iterator의 __next__() 메소드를 호출 --> next(iterator)
### 자기를 생성한 iterable객체의 원소를 하나 반환.
print(next(l_iterator))
```

    1
    


```python
print(next(l_iterator))
```

    2
    


```python
print(next(l_iterator))
```

    3
    


```python
print(next(l_iterator))
```


    ---------------------------------------------------------------------------

    StopIteration                             Traceback (most recent call last)

    Cell In[7], line 1
    ----> 1 print(next(l_iterator))
    

    StopIteration: 



```python
iterable = [1, 2, 3, 4, 5]
#1. iterable->iterator생성
iterator = iter(iterable)
while True:
    try:
        value = next(iterator)
        print(value)
    except StopIteration:
        break

print("다음작업")
```

    1
    2
    3
    4
    5
    다음작업
    


```python
def forIn(iterable, func): 
    # iterable: 원소를 제공할 iterable 객체
    # func: 각 원소를 처리한 함수.
    iterator = iter(iterable)
    while True:
        try:
            value = next(iterator)
            func(value)
        except StopIteration:
            break
            
# for value in iterable:
#     xxx
#     xx
```


```python
forIn([1,2, 3], lambda x : print(x))
forIn((10, 20, 30), lambda x : print(x))
```

    1
    2
    3
    10
    20
    30
    

## for in 문 Iterable의 값을 순환반복하는 과정

1. 반복 조회할 iterable객체의 __iter__() 를 호출 하여 Iterator를 구한다.
1. 매 반복마다 Iterator의 __next__() 를 호출하여 다음 원소를 조회한다.
1. 모든 원소들이 다 제공해 StopIteration Exception이 발생하면 반복문을 멈추고 빠져나온다.


```python
# Iterable 과 Iterator를 구현
## 각각 다른 클래스로 구현
class MyIterable:
    
    def __init__(self, *args):
        # **args: 제공할 원소값들을 가변인자로 받기.
        self.values = args
    
    # iterable
    def __iter__(self):
        # Iterable은 반드시 __iter__() 특수 메소드를 구현해야한다.
        # __iter__()는 Iterator객체를 반환 하도록 구현.
        return MyIterator(self.values)
    
    # subscriptable - indexing 가능
    def __getitem__(self, index):
        return self.values[index]
    
    # len(객체) 호출되는 특수메소드 -> 원소의 개수를 반환.
    def __len__(self):
        return len(self.values)
```


```python
i = MyIterable(1, 2, 3)
i[2]
len(i)
```




    3




```python
class Person:
    __init__()
    __str__(), __repr__()
    __add__() __sub__().. __gt__(), __ge__() 연산자 특수메소드 재정의
    # iterable 
    __iter__()
    # iterator
    __next__()
    # subscriptable - indexing
    __getitem__() + __len__()
```


```python
# p = Person() => __init__()
# str(p), print(p) => __str__()
# p + 30, p + p2, p - p2, p * 50  
#                --> 산술 연산자 처리리 메소들 (__add__(), __sub__(), __mul__()
# iter(p) -> __iter__() ==> iterator 반환
# next(p) -> __next__() ==> 원소 한개를 제공
# p[3]  -> __getitem__(3)
# len(p) -> __len__()
```


```python
class MyIterator:
    
    def __init__(self, values):
        # Itarator가 제공할 값을 MyIterable로 부터 받는다.
        self.values = values
        self.index = 0  # 제공할 값의 index
        
    def __next__(self):
        # Iterator는 반드시 __next__() 특수 메소드를 구현해야한다.
        ## Iterable에서 받은 원소들에서 하나의 값을 순서대로 제공하도록 구현.
        ## 더 제공할 값이 없으면 StopIteration 예외를 발생시킨다.
        if len(self.values) <= self.index:
            raise StopIteration()
        r_value = self.values[self.index] # 제공할 값을 조회
        self.index += 1  #  index를 하나 증가
        return r_value
```


```python
i = MyIterable(1, 2, 3, 4, 5) #iterable 생성
it = iter(i)  # iterable로 부터 iterator를 생성
```


```python
# iterator로부터 한개의 값을 조회
next(it)
```




    1




```python
next(it)
```




    5




```python
it.index
next(it)
```


    ---------------------------------------------------------------------------

    StopIteration                             Traceback (most recent call last)

    Cell In[30], line 2
          1 it.index
    ----> 2 next(it)
    

    Cell In[22], line 13, in MyIterator.__next__(self)
          8 def __next__(self):
          9     # Iterator는 반드시 __next__() 특수 메소드를 구현해야한다.
         10     ## Iterable에서 받은 원소들에서 하나의 값을 순서대로 제공하도록 구현.
         11     ## 더 제공할 값이 없으면 StopIteration 예외를 발생시킨다.
         12     if len(self.values) <= self.index:
    ---> 13         raise StopIteration()
         14     r_value = self.values[self.index] # 제공할 값을 조회
         15     self.index += 1  #  index를 하나 증가
    

    StopIteration: 



```python
i = MyIterable(1, 2, 3, 4, 5) 
# for v in i:
for v in MyIterable(1, 2, 3, 4, 5):
    print(v)
```

    1
    2
    3
    4
    5
    


```python
i = MyIterable(1, 2, 3, 4, 5) 
# i[0] ==> Iterable에 def __getitem__(self, idx): idx번째 값을 반환하는 메소드
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    Cell In[32], line 2
          1 i = MyIterable(1, 2, 3, 4, 5) 
    ----> 2 i[0]
    

    TypeError: 'MyIterable' object is not subscriptable


## Generator
- Iterable과 Iterator를 합친 기능을 함수 형태로 구현(정의)한 것을 generator라고 한다.
    - 제공할 값들을 미리 메모리에 올리지 않고 로직을 통해 값들을 호출자가 필요할 때 마다 제공할 때 유용하다.
- 제너레이터 함수에서 값을 반환
    - **yield 반환값**
        - 반환값을 가지고 호출한 곳으로 돌아간다. 현재 상태(돌아가기 직전 상태)를 기억하면서 돌아간다. 
            - 값을 반환하고 일시정지 상태라고 생각하면 된다.
        - 다음 실행시점에 yield 구문 다음 부터 실행된다.
    - **return \[valuye\]**
        - generator 함수 종료
        - StopIteration 발생시킨다.
- Generator 의 원소 조회
    - next(Generator객체)


```python
def my_gen():
    
    yield 10

    yield 2

    yield 3
```


```python
g = my_gen()  # generator  객체를 생성
# generator 호출
next(g)  # yield다음구문 ~ yield
```




    10




```python
next(g)
```




    2




```python
next(g)
```




    3




```python
next(g)
```


    ---------------------------------------------------------------------------

    StopIteration                             Traceback (most recent call last)

    Cell In[47], line 1
    ----> 1 next(g)
    

    StopIteration: 



```python
v = next(g)
print(v)
print(v+10)
next(g)
next(g)
next(g)
```


```python
# 파라미터로 받은 값에서 5씩 증가하는 값을 3번 제공.
def my_gen2(start):
    start += 5
    yield start
    
    start += 3
    yield start
    
    start += 22
    yield start
```


```python
g2 = my_gen2(10)
print(next(g2))
```

    15
    


```python
print(next(g2))
```

    20
    


```python
print(next(g2))
```

    25
    


```python
print(next(g2))
```


    ---------------------------------------------------------------------------

    StopIteration                             Traceback (most recent call last)

    Cell In[53], line 1
    ----> 1 print(next(g2))
    

    StopIteration: 



```python
def my_gen3(start, n):
    # start부터 5씩 증가하는 값을 n개 제공
    for _ in range(n):
        start += 5
        yield start
```


```python
g3  = my_gen3(1, 10) # generator 객체 생성
```


```python
v = next(g3)
print(v)
v = next(g3)
print(v)
```

    6
    11
    

### Generator 표현식 (Generator Comprehension)
- 컴프리헨션구문을 **( )** 로 묶어 표현한다.
- 컴프리헨션 구문안의 Iterable의 원소들을 처리해서 제공하는 generator 표현식
- Generator Comprehension 은 반복 가능한 객체만 만들고 실제 원소에 대한 요청이 왔을 때 값을 생성한다.
    - 메모리 효율이 다른 Comprehension들 보다 좋다.


```python
(v*5 for v in iterable if 조건)
```


```python
g4 = (value+5 for value in range(10) )
```


```python
g4
```




    <generator object <genexpr> at 0x00000275F6B176B0>




```python
next(g4)
```




    11




```python
l = [1, 2, 3, 4]
(v for v in range(1, 5))
```

# Decorator (장식자)

## 파이썬에서 함수는 일급 시민(first class citizen) 이다.
- 일급 시민 (first class citizen) 이란
    1. 변수에 대입 할 수 있다.
    2. Argument로 사용할 수 있다.
    3. 함수나 메소드의 반환값으로 사용 할 수 있다.
    


```python
def 가():
    pass

def 나():
    
    pass
가()
나()
```


```python
def 다():
    가()
    
def 라(a): # outer function
    
    def 마(): # inner function
#         a = a + 10
        print(a+10)
    마()
    마()
    마()
    마()
    b = 10
#     return b
    return 마

```


```python
b = 라(1)
print(b)
```

    11
    11
    11
    11
    <function 라.<locals>.마 at 0x00000275F78A1EE0>
    

## 지역함수(Local Function) 란
- 함수 안에 정의 한 함수를 말한다.
    - 중첩 함수(Nested function) 이라고도 한다.
- 지역함수가 선언된 함수를 **outer function** 지역함수는 **inner function** 이라고 한다. 
- inner function은 outer function의 지역변수를 자유롭게 사용할 수 있다.
- 기본적으로 inner function은 outer function 안에서만 호출 할 수있다.
- 단 outer function이 정의된 inner function을 return value로 반환하면 밖에서도 호출 할 수 있다.


```python
# 변수 - global(전역) 변수, local(지역) 변수
## 변수의 사용범위 (scope) => 그 변수가 선언된 영역(block) 내에서 호출 가능.
#                                                         ==> 하위 영역(block에서도 호출-사용가능)
## 함수에서 global 변수의 값을 변경할 경우:  global 변수명  
## inner 함수에서 outer 함수의 local 변수를 변경:  nonlocal  변수명

global_var = "Global (전역)변수"
print(1, global_var)

def outer():
    global global_var  # 변경할 경우 -> 선언.
    
    local_var = "Outer함수의 Local (지역)변수"
    print(2, global_var)
    print(3, local_var)
    # global 변수값을 변경
    
    global_var = "outer에서 변경한 global_var의 값"
    print(global_var)
    
    def inner():
        # outer 함수의 지역변수를 변경할 경우 -  nonlocal  변수명  으로 선언을 먼저해야 한다.
        nonlocal local_var 
        
        inner_local_var = "Inner 함수의 Local (지역) 변수"
        print(4, global_var)
        print(5, local_var)
        local_var = "Inner에서 변경한 local_var 의 값"
        print("5-2", local_var)
        print(6, inner_local_var)
#     print(inner_local_var) # inner()함수에서 정의한 지역변수는 outer함수에서 호출 안됨.
    inner()
    print("5-3", local_var)

outer()
print(global_var)
# print(local_var)
```

    1 Global (전역)변수
    2 Global (전역)변수
    3 Outer함수의 Local (지역)변수
    outer에서 변경한 global_var의 값
    4 outer에서 변경한 global_var의 값
    5 Outer함수의 Local (지역)변수
    5-2 Inner에서 변경한 local_var 의 값
    6 Inner 함수의 Local (지역) 변수
    5-3 Inner에서 변경한 local_var 의 값
    outer에서 변경한 global_var의 값
    

## Closure (클로저)
- 지역함수(Inner function)를 정의한 Outer function이 종료되어도 지역함수가 종료될 때까지 outer function의 지역변수들은 메모리에 계속 유지 되어 inner function에서 사용할 수 있다. 
- 파이썬 실행환경은 inner function이 종료될때 까지 outer function의 지역변수들(parameter포함)을 사용할 수 있도록 저장하는 공간이 **closure**이다.


```python
def outer():
    outer_var = 10 # outer함수의 지역변수
    
    def inner():
        print(outer_var)  #inner함수에서 outer함수의 변수를 호출
    
    return inner   # inner함수를 반환
```


```python
f = outer()  # f = inner함수
f()
```

    10
    


```python
f()
```

    10
    

## Decorator (장식자)
- 기존의 함수를 수정하지 않고 그 함수 전/후에 실행되는 구문을 추가할 수 있도록 하는 함수를 말한다.
- 기존 함수코드를 수정하지 않고 새로운 기능의 추가를 쉽게 해준다.
- 추가기능을 다수의 함수에 적용할 수 있다.
- 함수의 전/후처리 하는 구문을 **필요하면 붙이고 필요 없으면 쉽게 제거할 수 있다**

![개요](images/ch10_01.png)


```python
def a():
    print("안녕하세요.")

    
def b():
    print("Hello!")
```


```python
# print("="*50)
# a()
# print("="*50)
# 전처리 - 추가 다양한 방식 적용
# a() => 함수를 수정안하고.
# 후처리 - 추가
# b()
# a()
```


```python
def equal_deco(func): # 파라미터 -> 함수를 받는다. => original 기능을 실행할 함수
    
    # inner함수:original 함수 호출을 처리하는 함수.  함수 호출 전후로 해야할 것을 있으면 그 처리를 한다.
    def wrapper():
        print("="*30)  # 전처리
        func()  #원래 함수의 작업
        print("="*50)  # 후처리
        
    return wrapper
```


```python
def sharp_deco(func):
    
    def wrapper():
        print("#"*30)
        func()
        print("#"*30)
        
    return wrapper
```


```python
# a()
a_f = equal_deco(a)
a_f()   # 실행된(호출한) 함수: wrapper() 
```

    ==============================
    안녕하세요.
    ==================================================
    


```python
a()
```

    안녕하세요.
    


```python
# 데코레이터 함수에 오리지날 함수를 전달해서 호출 
#                                         -> wrapper 함수를 반환값을 받는다. -> wrapper함수를 호출
a_f2 = sharp_deco(a)
a_f2()
```

    ##############################
    안녕하세요.
    ##############################
    


```python
b_f = equal_deco(b)
b_f()
```

    ==============================
    Hello!
    ==================================================
    


```python
# decorator 를 오리지날 함수 정의시 추가하라고 선언.
@sharp_deco
def a2():
    print("안녕하세요")
```


```python
a2()
```

    ##############################
    안녕하세요
    ##############################
    


```python
a2
```




    <function __main__.sharp_deco.<locals>.wrapper()>




```python
# @equal_deco
@sharp_deco
def b2():
    print("hello!!!")
```


```python
b2()
```

    ##############################
    hello!!!
    ##############################
    


```python
def sharp_deco2(func):
    # original 함수가 파라미터를 받을 경우 그것을 wrapper() 함수에 설정한다.
    def wrapper(param):
        print("#"*50)
        result = func(param) # original 함수 호출
        print("#"*50)
        if len(result) < 7:
#             raise Exception("결과값이 모자랍니다.")
            result = "   "+ result
        return result
    return wrapper
```


```python
@sharp_deco2
def greet(name):
    print(f"{name}님 환영합니다.")
    return f"인사말-{name}"
```


```python
# sharp_deco.wrapper
v = greet("홍")
print(v)
```

    ##################################################
    홍님 환영합니다.
    ##################################################
       인사말-홍
    

### Decorator 구현 및 사용

- 구현
    1. 전/후처리 기능을 추가할 함수를 parameter로 받는다.
    2. 그 함수 호출 전후로 추가할 기능을 작성한 **지역함수**를 정의한다.
    3. `2`번의 함수를 반환한다.
```python
def decorator(func):
    def wrapper([parameter]): # decorator 적용할 함수에 파라미터를 전달할 경우 parameter 변수들을 선언
        # 전처리
        func()
        # 후처리
    return wrapper 
```

- 호출
    - `@decorator이름`를 적용하고자하는 함수 선언전에 기술한다.
```python
@decorator
def caller([parameter]):
    ...
```

# 연습문제
함수가 실행된 실행시간(초)을 재는 decorator


```python
import time

# 1970년 1월 1일 0시 0분 0초 부터 time.time() 함수가 실행된 시점까지 몇초 지났는지를 반환.
# 1970년 1월 1일 0시 0분 0초 부터 얼마지났는지로 현재시간을 관리 => timestamp
v = time.time()
print(v)
```

    1693200340.9720309
    


```python
v = time.time()
print(v)
```

    1693200380.337939
    


```python
s = time.time()
for _ in range(3):
    print("a")
    time.sleep(1)  # sleep(초) 설정한 초만큼 실행을 멈춘다.
#     print("b")
e = time.time()
print(e-s, "초")
```

    a
    a
    a
    3.000978708267212 초
    


```python
import time
# 함수가 실행하는데 걸린 시간을 체크하는 decorator  정의

def timechecker(func):
    
    def wrapper(*args, **kwargs):
        s = time.time()
        v = func(*args, **kwargs)
        e = time.time()
        print(f"{func.__name__}()의 걸린시간: {e-s:.2f} 초")
        return v
    
    return wrapper
```


```python
@timechecker
def func1(a):
    print(1, a)
    time.sleep(2)
    print(2)
```


```python
# @timechecker
def func2(a, b, c):
    print(1, a, b, c)
    time.sleep(1)
    print(2)
```


```python
@timechecker
def func3():
    print(1)
    time.sleep(1)
    print(2)
```


```python
func1(10)
func2("A", "B", "C")
func3()

# 각 함수가 실행되는데 걸린 시간을 출력
```

    1 10
    2
    func1의 걸린시간: 2.00 초
    1 A B C
    2
    1
    2
    func3의 걸린시간: 1.00 초
    


```python
def test():
    pass

test.__name__  # 함수의 이름을 조회
```




    'test'




```python
# 반올림 (내장함수)
round(2.0009281635284424)
round(2.0009281635284424, 5) # 5: 자리수 - 소수점 5자리 이하에서 반올림
round(199.999, -1)

# 0 : 소숫점이하에서 반올림
# 양수 -> 소수점 위치
# 음수 -> 정수부 위치
```




    200.0




```python
a = 2.12939281635284424
f"{a:.2f} 초"  # .2f  .2 소숫점 2자리 이하에서 반올림.  f: float 타입
```




    '2.13 초'


