---
layout: single
title: '입출력'
typora-root-url: ../
---

# Path (경로)

- **경로(Path)**
    - 프로그램에서 사용할 **자원의 위치를 path(경로)** 라고 한다.
    - **파일 시스템**에서는 파일이나 디렉토리가 있는 위치의 경로를 말한다.
    

- **절대경로**
    - 자원의 전체 경로를 표현하는 방식
    - 시작 경로부터 자원(파일, 디렉토리)이 있는 위치까지 표현한다.
        - 시작 경로: Root Path
            - windows: `c:`, `d:`
            - Unix, Linux: `/`

- **상대경로**
    - 현재 작업 경로(위치)에서 부터 자원이 있는 위치까지 표현한다.
        - 시작 경로: 현재 작업경로
    - 구문
        - `.` : 현재 디렉토리
        - `..`: 상위 디렉토리
        - `/` : 경로 구분자,  상위경로/하위경로

- 운영체제(O/S)별 경로구분자
    - 윈도우즈: `\` (역슬래쉬)
    - 리눅스/유닉스: `/` (슬래쉬)


```python
# 경로를 문자열로 표시
file_path1 = "c:\\tlasses\\01_python\\calculater.py"  #절대경로
file_path2 = r"c:\tlasses\01_python\calculater.py"  #r-string: escape 문자 처리를 안함.
print(file_path1)
print(file_path2)
```

    c:\tlasses\01_python\calculater.py
    c:\tlasses\01_python\calculater.py
    


```python
file_path3 = "/src/python/a.py" #  절대경로
file_path4 = "./python/a.py"  # 상대경로. 
file_path5 = "python/a.py"  # 상대경로.   시작의 `./`는 생략 가능
file_path6 = "calculater.py" 
# 상대경로 -> ./calculater.py에서 `./`를 생략. 현재 디렉토리에 있는 calculater.py
```


```python
# 현재 경로 -> working directory
## => 현재 실행중인 프로그램의 위치
###  주피터노트북-> 노트북파일의 위치
### script 파일 실행 -> script 파일의 위치
```


```python
# 현재 working directory 조회
import os
cwd = os.getcwd()
print(type(cwd), cwd)
```

    <class 'str'> C:\classes\01_Python
    


```python
root = os.getcwd()
src_file = os.path.join(root, "src", 'abc.py')
# open(src_file)
```




    'C:\\classes\\01_Python\\src\\abc.py'




```python
root = r"c:\classes\01_python"
a_path = os.path.join(root, "a")
b_path = os.path.join(root, "b")
test_path = os.path.join(root, "test")
d_path = os.path.join(test_path, "d")
```


```python

```


```python
# f_path = "./calculater.py"
f_path = "calculater.py"
# 파일이 있는지 여부 조회
os.path.isfile(f_path)  # f_path에 파일이 있는지 여부
```




    False




```python
# 현재 working directory를 변경
os.chdir(r"c:\User_manual")  # ./ => c:\User_manual로 변경
print(os.getcwd())
```

    c:\User_manual
    


```python
os.path.isfile(f_path)
```




    False




```python
# os 모듈의 파일/디렉토리 관련 함수들
# 디렉토리 생성
try:
    os.mkdir(r"c:\classes\source") 
    # source디렉토리를 c:\classes 하위에 생성
    ## 이미 디렉토가 있거나, 생성하려는 디렉토리(c:\classes)가 없으면 Exception 발생.
except FileExistsError:  # 이미 있는 디렉토리
#     print("생성못함")
    pass
except FileNotFoundError:  # 생성하려는 상위디렉토리가 없어서 발생
    print("상위디렉토리를 먼저 생성")
```

    상위디렉토리를 먼저 생성
    


```python
#  exist_ok=False(기본) 이미 있는 디렉토리면 Exception 발생
#  exist_ok=True: 디렉토리가 있으면 무시
os.makedirs(r"c:\class\source", exist_ok=True)
# 상위 디렉토리가 없으면 상위디렉토리도 만들어준다.
```


```python
# 디렉토리 삭제 -> 빈 디렉토리만 삭제 가능.
# os.rmdir(r"c:\class")
os.rmdir(r"c:\class\source")
```


```python
os.rmdir(r"c:\class")
```


    ---------------------------------------------------------------------------

    NameError                                 Traceback (most recent call last)

    Cell In[12], line 1
    ----> 1 os.rmdir(r"c:\class")
    

    NameError: name 'os' is not defined



```python
# 파일 삭제
os.remove(r"c:\classes\아나콘다_주피터노트북_설치.pdf")
# 경로: 상대/절대 모두 가능.
```


```python
file_list = os.listdir(r"C:\classes\01_Python") 
#지정한 디렉토리의 하위요소들의 이름 문자열을 리스트에 담아 반환.
```


```python
file_list
```




    ['.ipynb_checkpoints',
     '01_개요.ipynb',
     '02_변수와 데이터타입.ipynb',
     '03_자료구조.ipynb',
     '04_제어문_컴프리헨션.ipynb',
     '05_함수.ipynb',
     '06_객체지향프로그래밍.ipynb',
     '07_패키지_모듈_import.ipynb',
     '08_예외처리 (Exception Handling).ipynb',
     '09_입출력.ipynb',
     '10_Iterable과 Decorator.ipynb',
     '11_파이썬 정규표현식.ipynb',
     'calculater.py',
     'images',
     'my_package',
     'python_script.py',
     'python_template92.zip',
     'test python.ipynb',
     'test.py',
     '__pycache__']




```python
os.path.join("a", "b", "c", "d")
```




    'a\\b\\c\\d'




```python
root_path = r"c:\classes\01_Python"
for file in file_list:
    file_path = os.path.join(root_path, file)
#     print(file_path)
#     break
    if os.path.isfile(file_path):
        print("File-", file)
    elif os.path.isdir(file_path):
        print("Dir-", file)
```

    Dir- .ipynb_checkpoints
    File- 01_개요.ipynb
    File- 02_변수와 데이터타입.ipynb
    File- 03_자료구조.ipynb
    File- 04_제어문_컴프리헨션.ipynb
    File- 05_함수.ipynb
    File- 06_객체지향프로그래밍.ipynb
    File- 07_패키지_모듈_import.ipynb
    File- 08_예외처리 (Exception Handling).ipynb
    File- 09_입출력.ipynb
    File- 10_Iterable과 Decorator.ipynb
    File- 11_파이썬 정규표현식.ipynb
    File- calculater.py
    Dir- images
    Dir- my_package
    File- python_script.py
    File- python_template92.zip
    File- test python.ipynb
    File- test.py
    Dir- __pycache__
    

# 입출력 (IO)

## 입출력이란
- 프로그램이 사용하려는 외부 자원을 연결하여 데이터를 입력 받거나 출력하는 작업을 IO라고 한다.
- 외부 자원
    - 파일, 원격지 컴퓨터(Network으로 연결된 컴퓨터의 자원), 데이터베이스 등.
- **Stream**
    - 입출력 시 **데이터의 흐름을 stream** 이라고 한다.
- InputStream 
    - Program이 외부로 부터 데이터를 읽어 들이는 흐름.
- OutputStream 
    - Program이 외부로 데이터를 써주는 흐름.


![io](images/ch09_01.png)

## IO 코딩 순서
![순서](images/ch09_02.png)

### 파일 열기(연결)
- open() 함수 사용
    - 연결된 파일과 입출력 메소드를 제공하는 객체(Stream)를 리턴
- 구문
    - `open(file, mode='r', encoding=None)`
    - 함수 주요 매개변수
        - file : 연결할 파일 경로
        - mode : 열기 모드
            - mode는 목적, 데이터종류를 조합한 문자열을 사용한다.
        - encoding 
            - 텍스트 파일일 경우 인코딩 방식
            - None 또는 생략하면  os 기본 encoding방식을 따른다.
                - Windows: cp949/euckr
                - Linux, Unix: utf-8
|mode타입|mode문자|설명|
|:-|-|-|
|목적|r|읽기 모드-목적의 기본 모드|
||w|새로 쓰기 모드|
||a|이어 쓰기 모드|
||x|새로 쓰기모드-연결하려는 파일이 있으면 Exception발생|
|데이터종류|b|binary 모드|
||t|Text모드-text데이터 입출력시 사용|
    

### 출력 메소드

- write(출력할 Data)
    - 연결된 파일에 `출력할 Data` 출력한다.
- writelines(문자열을 가진 컬렉션)
    - 리스트, 튜플, 집합이 원소로 가진 문자열들을 한번에 출력한다.
    - text 출력일 경우에만 사용가능.
    - 원소에 문자열 이외의 타입의 값이 있을 경우 TypeError 발생


```python
import os
os.chdir(r"c:\classes\01_python")
print(os.getcwd())
```

    c:\classes\01_python
    


```python
# 출력할 파일들을 저장할 디렉토리를 생성
os.makedirs("files", exist_ok=True)
# 1. 출력할 파일과 연결
fw = open("files/test.txt", #연결할 파일의 경로
          mode="wt", # w: 출력(파일이 없으면 만들어서 연결, 있으면 연결후에 파일내용을 삭제), t: text -> 생략가능.
          encoding="utf-8" # 문자열 인코딩 방식. 생략: os의 기본 인코딩방식(win:cp949, mac: utf-8)
         )
print(type(fw))
# 2. 출력(Output) 작업
fw.write("안녕하세요.\n")
fw.write("반갑습니다.\n")
fw.write("Hello World")

# 3. 파일과 연결 닫기
fw.close()
```

    <class '_io.TextIOWrapper'>
    


```python
# 1. 출력할 파일과 연결
fw = open("files/test2.txt", #연결할 파일의 경로
          mode="at", # a: 출력-이어쓰기, t: text -> 생략가능.
          encoding="utf-8" # 문자열 인코딩 방식. 생략: os의 기본 인코딩방식(win:cp949, mac: utf-8)
         )
print(type(fw))
# 2. 출력(Output) 작업
fw.write("안녕하세요.\n")
fw.write("반갑습니다.\n")
fw.write("Hello World")

# 3. 파일과 연결 닫기
fw.close()
```

    <class '_io.TextIOWrapper'>
    


```python
# 연결
fw = open("files/test4.txt", "wt", encoding="utf-8")
txt = ["aaaaaa", "1111111", '가가가가가가가', "3333333", "ggggggg"]
# 출력
# for t in txt:
#     fw.write(t)
fw.writelines(txt)  # 엔터를 자동으로 넣어주지 않음.

# 연결닫기
fw.close()
```


```python
#### TextIOWrapper (fw) 의 속성 조회 => 연결 Stream 정보
print(fw.mode, fw.encoding, fw.name)
print("연결 여부를 확인: ", fw.closed)
"연결닫힘" if fw.closed else "연결중임"
```

    wt utf-8 files/test4.txt
    연결 여부를 확인:  True
    




    '연결닫힘'




```python
fw = open("files/test4.txt", "wt")
print(fw.closed)
```

    False
    


```python
fw.close()
```

### 입력 메소드
- read() : 문자열(text mode), bytes(binary mode) 
    - 연결된 파일의 내용을 한번에 모두 읽어 들인다.
- readline() : 문자열(text mode), bytes(binary mode)
    - 한 줄만 읽는다.
    - text 입력일 경우만 사용가능
    - 읽은 라인이 없으면 `빈문자열`을 리턴한다.
- readlines() : 리스트
    - 한번에 다 읽은 뒤 각각의 라인을 리스트에 원소로 담아 반환한다.
- Input Stream (TextIOWrapper, BufferedReader)는 Iterable 타입
    - for문을 이용한 라인단위 순차 조회할 수 있다.


```python
# 읽기
## 1. 연결
fr = open("files/test.txt", mode="rt", # r: 기본, t: 기본 (rt일 경우는 생략가능.)
         encoding="utf-8")
## 2. 읽기
read_txt = fr.read() # 전체를 한번에 읽어온다.
print(read_txt)

## 3. 연결닫기
fr.close()
```

    안녕하세요.
    반갑습니다.
    Hello World
    


```python
## 1. 연결
fr = open("files/test.txt", mode="rt", # r: 기본, t: 기본 (rt일 경우는 생략가능.)
         encoding="utf-8")
## 2. 읽기
# read_txt = fr.readline()  #  한줄만 읽는다. ........\n (엔터 까지만 읽는다.)
# print(read_txt)
# read_txt = fr.readline()
# print(read_txt)
read_txt = fr.readline() # 한줄 읽은 것이 없으면 빈문자열 반환.
while read_txt:
    print(read_txt, end="")
    read_txt = fr.readline()


## 3. 연결닫기
fr.close()
```

    안녕하세요.
    반갑습니다.
    Hello World


```python

```


```python
fr = open("files/test.txt", mode="rt", encoding="utf-8")
txt_list = fr.readlines()
fr.close()

print(txt_list)
```

    ['안녕하세요.\n', '반갑습니다.\n', 'Hello World']
    


```python
for line_no, txt in enumerate(txt_list, start=1):
    print(f"{line_no}. {txt.strip()}")
```

    1. 안녕하세요.
    2. 반갑습니다.
    3. Hello World
    


```python
fr = open("files/test.txt", mode="rt", encoding="utf-8")
# Text입력 Stream (TextIOWrapper) ==> Iterable 타입 ===> for in 문으로 사용가능
## ===> 한번 반복할 때마다 한줄 읽은 것을 반환.

for ln, txt in enumerate(fr, start=1):
    print(ln, txt.strip())

fr.close()
```

    1 안녕하세요.
    2 반갑습니다.
    3 Hello World
    


```python
# 앞의 2줄만 읽기
fr = open("files/test.txt", mode="rt", encoding="utf-8")
for _ in range(2):
    print(fr.readline())
fr.close()
```

    안녕하세요.
    
    반갑습니다.
    
    

## with block

파일과 입출력 작업이 다 끝나면 반드시 연결을 닫아야 한다. 매번 연결을 닫는 작업을 하는 것이 번거롭고 실수로 안 닫을 경우 문제가 생길 수 있다. **with block은 block을 벗어나면 자동으로 연결을 닫아 준다.** 그래서 연결을 닫는 코드를 생략할 수 있다.

- 구문
```python
with open() as 변수: # `변수`는 open()이 반환하는 Stream객체를 참조한다.
    입출력 작업      # 변수를 이용해 입출력 작업을 처리한다.
# with block을 빠져 나오면 close()가 자동으로 실행된다.
```


```python
fr = open("files/test.txt", "rt", encoding="utf-8") 
```


```python
with open("files/test.txt", "rt", encoding="utf-8") as fr:
    txt = fr.read()
#     print(10/0)

# with block을 빠져 나옴. => 자동을 stream이 close 된다.
print(txt)
print(f"fr 연결여부: {fr.closed}")

```


    ---------------------------------------------------------------------------

    ZeroDivisionError                         Traceback (most recent call last)

    Cell In[108], line 3
          1 with open("files/test.txt", "rt", encoding="utf-8") as fr:
          2     txt = fr.read()
    ----> 3     print(10/0)
          5 # with block을 빠져 나옴. => 자동을 stream이 close 된다.
          6 print(txt)
    

    ZeroDivisionError: division by zero



```python
try:
    연결
    입/출력
except:
    예외처리
finally:
    fr.close()
```


```python

```

# binary 데이터 입출력
binary data -> 텍스트 인코딩을 하지 않고 입출력하는 데이터.   
각 타입의 값들을 출력(binary) 할때 `bytes` 타입으로 변환해서 출력  
binary data를 입력받으면 `bytes` 타입으로 반환.  
각 타입 -> bytes : 출력
bytes -> 각 타입 : 입력


```python
i = 10
with open("files/data.txt", 'wt') as fw:
    # text mode로 출력 -> str 타입만 가능
    fw.write(str(i))
```


```python
with open("files/data.txt", 'rt') as fr:
    a = fr.read()  # text 모드: return type - str
    
print(int(a) + 20)
```

    30
    


```python
print(type(10))  
```

    <class 'int'>
    


```python
i = 10
# binary data 로 출/입력
# 정수 i를 bytes 타입을 변환
# (크기, 구성방식, 부호있는지여부)
# byteorder - little: 유효숫자이외의 0을 앞에 채움 (00000001)
#             big: 유효숫자 이외의 0을 뒤에 채움 (10000000)
#    정수->bytes, bytes->정수  ==> byteorder를 동일하게 지정.
i_bytes = i.to_bytes(1, byteorder="little", signed=True)
with open("files/data2.dat", "wb") as fo:
#     print(type(fo))
#     fo.write(i)
    fo.write(i_bytes)
```


```python
with open("files/data2.dat", "rb") as fi:
#     print(type(fi))
    value = fi.read()  # b 모드로 읽기: bytes 타입을 return
```


```python
type(value)
```




    bytes




```python
# bytes->int 변환
i_value = int.from_bytes(value, byteorder="little", signed=True)
print(i_value + 50)
```

    60
    


```python
int(원래타입) -변환-> bytes --출력--> 저장 --입력--> bytes -변환->int(원래)
```

# pickle 모듈을 이용한 객체 직렬화

## 객체 직렬화(Object Serialization)
- 객체의 속성값들을 bytes로 변환해 출력하는 것을 객체 직렬화(Object Serialization) 이라고 한다.
- bytes로 출력된 데이터를 읽어 객체화 하는 것을 객체 역직렬화(Object Deserialization) 이라고 한다.

### pickle
- 객체 파일 입출력을 위한 파이썬 모듈
- open() 시 **binary mode**로 설정한다.
- 저장시 파일 확장자는 보통 `pkl` 이나 `pickle` 로 한다.
- ex)
```python
fw = open("data.pkl", "wb") # 객체를 pickle에 저장하기 위한 output stream 생성
fr = open("data.pkl", "rb") # 파일에 저장된 객체를 읽어오기 위한 input stream 생성
```
- **메소드**
    - dump(저장할 객체, fw) : 출력
    - load(fr): 입력 - 읽은 객체를 반환한다.


```python
i = 10
import pickle
# 출력 -> 직렬화 
with open("files/int_data.pickle", "wb") as fo:
    pickle.dump(i, fo)
```


```python
# 입력 -> 역직렬화
with open("files/int_data.pickle", "rb") as fi:
    r_value = pickle.load(fi)
```


```python
type(r_value), r_value
```




    (int, 10)




```python
l = [10, "abc", True]
with open("files/list.pickle", "wb") as fo:
    pickle.dump(l, fo)
```


```python
with open("files/list.pickle", "rb") as fi:
    r_list = pickle.load(fi)
    
type(r_list), r_list
```




    (list, [10, 'abc', True])




```python
from my_package import test_module as tm
p = tm.Person("홍길동", 20)
print(p)
```

    이름: 홍길동, 나이: 20
    


```python
f_name = "files/person.pickle"
with open(f_name, "wb") as fo:
    pickle.dump(p, fo)
```


```python
with open(f_name, "rb") as fi:
    r_person = pickle.load(fi)
```


```python
type(r_person)
```




    my_package.test_module.Person




```python
print(r_person)
```

    이름: 홍길동, 나이: 20
    

# TODO

- 간단한 터미널 기반 메모장
    1. 사용자로부터 파일명을 입력받는다.
    2. 사용자로부터 파일에 저장할 문장을 입력받아서 파일에 저장한다.
        - 한줄씩 입력받는다.
        - 사용자가 !q 를 입력하면 저장후 종료한다.
    3. 사용자가 저장한 파일을 읽어서 출력한다.



```python
os.makedirs("files", exist_ok=True)  # 파일들을 저장할 디렉토리 생성
# 1. 파일명 입력
filename = input("저장할 파일명:")
file_path = os.path.join("files", filename)
print(file_path)
# 2. 연결
fw = open(file_path, "wt", encoding="utf-8")
print("저장할 text를 입력하세요.")
# 3. !q가 입력될때까지 출력
while True:
    line = input(">>>")
    if line == "!q":
        break
    fw.write(line+"\n")  #input() 은 엔터는 읽지 않는다. 그래서 뒤에 엔터를 추가
    # fw.write() -> buffer(임시저장소)에 출력
    # fw.flush() # buffer내용을 연결된 자원에 출력
print("종료")
# 4. close (종료)
fw.close()

```

    저장할 파일명:c.txt
    files\c.txt
    저장할 text를 입력하세요.
    >>>a
    >>>ab
    >>>d
    >>>d
    >>>d
    >>>d
    >>>d
    >>>dd
    >>>!q
    종료
    


```python
fw.close()
```


```python
os.makedirs("files", exist_ok=True)
filename = input("저장할 파일명:")
file_path = os.path.join("files", filename)
# with block 구현
with open(file_path, 'wt', encoding="utf-8") as fw:
    print(" 저장할 내용을 입력하세요.")
    while True:
        #한줄 읽기
        line_txt = input(">>>")
        #!q 입력됐으면 종료
        if line_txt == "!q":
            break
        # 파일 출력
        fw.write(line_txt+"\n")

#with block  종료시 close는 자동을 처리
print("종료")
```

    저장할 파일명:d.txt
     저장할 내용을 입력하세요.
    >>>aaaa
    >>>bbb
    >>>ccc
    >>>ddd
    >>>eee
    >>>1111
    >>>!q
    종료
    


```python
"c:\\a\\b\\c"
```


```python
# 함수화
def simple_memo():
    os.makedirs("files", exist_ok=True)
    filename = input("저장할 파일명:")
    file_path = os.path.join("files", filename)
    # with block 구현
    with open(file_path, 'wt', encoding="utf-8") as fw:
        print(" 저장할 내용을 입력하세요.")
        while True:
            #한줄 읽기
            line_txt = input(">>>")
            #!q 입력됐으면 종료
            if line_txt == "!q":
                break
            # 파일 출력
            fw.write(line_txt+"\n")

    #with block  종료시 close는 자동을 처리
    print("종료")
```


```python
a=os.path.join('c:\\', "a", "b", "c")
open(a) 
```

    c:\a\b\c
    


```python
simple_memo()
```

    저장할 파일명:abc.txtg
     저장할 내용을 입력하세요.
    >>>a
    >>>b
    >>>c
    >>>Q1
    >>>!q
    종료
    


```python
simple_memo()
```

    저장할 파일명:dddd
     저장할 내용을 입력하세요.
    >>>d
    >>>!q
    종료
    


```python
%%writefile  simple_memo.py
import os
#  모듈화 + 실행 프로그램.
def simple_memo():
    os.makedirs("files", exist_ok=True)
    filename = input("저장할 파일명:")
    file_path = os.path.join("files", filename)
    # with block 구현
    with open(file_path, 'wt', encoding="utf-8") as fw:
        print(" 저장할 내용을 입력하세요.")
        while True:
            #한줄 읽기
            line_txt = input(">>>")
            #!q 입력됐으면 종료
            if line_txt == "!q":
                break
            # 파일 출력
            fw.write(line_txt+"\n")

    #with block  종료시 close는 자동을 처리
    print("종료")
    
if __name__ == "__main__":
    simple_memo()
```

    Overwriting simple_memo.py
    


```python
from simple_memo import simple_memo as s_memo

s_memo()
```

    저장할 파일명:aaa.txt
     저장할 내용을 입력하세요.
    >>>a
    >>>a
    >>>a
    >>>!q
    종료
    


```python
%%writefile  simple_memo.py

#  모듈화 + 실행 프로그램.
def simple_memo():
    os.makedirs("files", exist_ok=True)
    filename = input("저장할 파일명:")
    file_path = os.path.join("files", filename)
    # with block 구현
    with open(file_path, 'wt', encoding="utf-8") as fw:
        print(" 저장할 내용을 입력하세요.")
        while True:
            #한줄 읽기
            line_txt = input(">>>")
            #!q 입력됐으면 종료
            if line_txt == "!q":
                break
            # 파일 출력
            fw.write(line_txt+"\n")

    #with block  종료시 close는 자동을 처리
    print("종료")
    
if __name__ == "__main__":
    simple_memo()
```

- data/member.csv 파일을 읽어서 각 열의 값을 배열에 담는다.    
이름,나이,주소  형태의 csv를 읽어    
```python
names = []
ages =[]
addresses =[]    
```
리스트에 넣는다. 
- 단 첫줄은 head이므로 읽지 않는다.
- 참고 함수: 문자열 split(), for문 관련 enumerate()




```python
# 각 값들을 저장할 리스트
names = []  # list()
ages = []
addresses = []

# 한줄씩 읽어서 각각의 속성값들을 각 리스트에 추가.
## 1. 파일연결
with open("data/member.csv", "rt", encoding="utf-8") as fr:
    for line_no, line_txt in enumerate(fr):
        if line_no == 0: # 0번라인 -> header부분 을 제거
            continue  # 다음 반복 실행
        name, age, address = line_txt.strip().split(",")
        names.append(name)
        ages.append(age)
        addresses.append(address)
```


```python
names
ages
addresses
```




    ['서울', '인천', '부산', '광주', '대구', '울산']




```python
for name, age, address  in zip(names, ages, addresses):
    print(f"이름: {name}, 나이: {age}, 주소: {address}")
```

    이름: 유재석, 나이: 30, 주소: 서울
    이름: 박명수, 나이: 35, 주소: 인천
    이름: 정준하, 나이: 40, 주소: 부산
    이름: 노홍철, 나이: 55, 주소: 광주
    이름: 정형돈, 나이: 60, 주소: 대구
    이름: 하하, 나이: 65, 주소: 울산
    

> **CSV (Comma Separated Value)** 파일
> - 데이터들을 정형화(표)된 형태로 텍스트파일에 저장하는 방식
> - 하나의 데이터는 한줄에 표시. (데이터 구분자는 엔터)
> - 하나의 데이터를 구성하는 값들(속성)들은 , 로 구분
>     - tab으로 구분하는 경우 TSV 
>     - 각 속성값들은 " " 로 감싸기도 한다.
> - 텍스트기반
> - 파일 확장자는 `.csv`, `.tsv` 로 준다.
